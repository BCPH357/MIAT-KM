# MIAT碩士論文_2025_饒珮以_整合MIAT方法論與大型語言模型於系統設以指紋比對系統 文件提取與分析結果

**📖 目錄內容 (已清理)：**

```
1.1 研究背景 - P.1
1.2 研究動機與目的 - P.2
1.3 研究架構 - P.3
2.1 指紋特徵 - P.4
2.1.1 全域特徵 - P.4
2.1.2 局部特徵 - P.5
2.1.3 次級特徵 - P.6
2.2 指紋比對演算法 - P.8
2.2.1 Image correlation 演算法比對 - P.9
2.2.2 Phase 演算法比對 - P.12
2.2.3 Skeleton 演算法比對 - P.14
2.2.4 Minutia 演算法比對 - P.17
2.2.5 FLANN 演算法比對 - P.22
LLM 輔助生成 Grafcet action 程式碼 - P.29
3.2.1 指紋比對模組(A4) - P.32
3.2.2 線段旋轉排除模組(A41) - P.33
3.2.3 線段方向排除模組(A42) - P.34
3.2.4 特徵點比對模組(A43) - P.35
3.3.1 指紋特徵比對離散事件模型 - P.37
3.3.2 線段旋轉排除離散事件模型 - P.38
3.3.3 線段方向排除離散事件模型 - P.39
3.3.4 特徵點比對離散模型 - P.40
4.3.1 LLM 模型 - P.43
4.3.2 Grafcet Action 生成流程 - P.43
4.3.3 生成結果驗證 - P.45
4.4.1 指紋特徵點擷取 - P.49
4.4.2 Minutia 比對實驗 - P.51
5.1 結論 - P.61
5.2 未來展望 - P.62
圖 2.1 Minutia 類型-核心和三角形奇異點 - P.5
圖 2.2 Minutia 類型： (a) 山脊末端 (b) 山脊分岔 - P.5
圖 2.3 脊線 - P.6
圖 2.4 (a)脊線數量為 2 (b)脊線數量為 1 - P.7
圖 2.5 脊線曲率方向 (a)凹形 (b)凸形 - P.7
圖 2.6 將樣本圖像 t 對應到來源圖像 f - P.10
圖 2.7 相位比對流程圖 - P.13
圖 2.8 (a)區域座標系統(Base-ridge) (b)正特徵點 (c)負特徵點 - P.15
圖 2.9 骨架對應的區域骨架描述器 - P.15
圖 2.10 匹配對(Matching pairs)與其相關參數 - P.18
圖 2.11 𝑝𝑠、𝑞𝑠為中心的符合條件匹配對結果 - P.19
圖 2.12 KD 樹示意圖 - P.23
圖 3.1 MIAT 系統設計方法論 - P.25
圖 3.2 IDEF0 功能模組 - P.26
圖 3.3 IDEF0 表示 MIAT 方法論架構 - P.27
圖 3.4 Grafcet 範例 - P.28
圖 3.5 (a)Grafcet 狀態表示 (b)Grafcet 行為方塊 - P.29
圖 3.6 指紋辨識系統 IDEF0 模組階層規劃 - P.31
圖 3.7 指紋比對模組(A4) - P.32
圖 3.8 線段旋轉排除模組(A41) - P.33
圖 3.14 線段方向排除離散事件建模 - P.39
圖 3.15 特徵比對離散事件建模 - P.40
圖 4.1 每個資料庫指紋圖片範例 - P.42
圖 4.2 (a)輸入 Prompt 產生狀態 0-4 (b)實際產生狀態 0-4 的程式碼 - P.45
圖 4.3 (a)輸入狀態 40-43 的 Prompt (b)實際產生狀態 40-43 的程式碼 - P.46
圖 4.4 執行修正 Prompt - P.47
圖 4.5 產生修改後的程式碼 - P.47
圖 4.6 架構流程圖簡易 - P.48
圖 4.7 指紋比對模組 0 至 410 狀態的高階軟體合成狀態轉移結果 - P.48
圖 4.8 指紋比對系統操作介面 - P.49
圖 4.9 選取樣本特徵集(DB1_102_2)與測試特徵集(DB1_102_5) - P.50
圖 4.10 確認系統成功正確讀取特徵點數據 - P.50
圖 4.11 Minutia 比對實驗成功結果 - P.51
圖 4.12 Minutia 比對實驗失敗結果 - P.52
圖 4.13 線段與線段參數 - P.53
圖 4.14 FLANN 比對實驗成功結果 - P.55
圖 4.15 FLANN 比對實驗失敗結果 - P.56
圖 4.16 指紋比對相似度統計圖 - P.58
圖 4.17 指紋比對時間統計圖 - P.59
附圖 1 翻譯中文 Grafcet - P.72
附圖 2 架構邏輯確認 - P.72
```

---

國 立 中 央 大 學

資 訊 工 程 學 系 碩 士 論 文

* 整合 MIAT 方法論與大型語言模型於系統設計：

以指紋比對系統為案例研究

## Integration of MIAT Methodology and Large Language Models for System Design:

A Case Study of Fingerprint Matching System

研 究 生 : 饒珮以 指導教授 : 陳慶瀚 博士

中 華 民 國 114 年 1 月

## 中文摘要

本研究以指紋特徵比對系統為驗證案例，探討結合 MIAT 方法論系統設計 與大型語言模型的系統設計和高階合成方法。MIAT 方法論著重在系統的階層 式模組化的架構設計，以及演算法的離散事件建模，最後合成可維護、可擴展 的系統程式碼。在方法論的最後階段，我們引進大型語言模型生成每個離散事 件狀態所驅動所需要的程式碼。為了驗證這個方法，我們設計了指紋特徵比對 系統的階層模組，包括旋轉排除模組、線段方向排除模組及特徵比對模組。實 驗部分，基於 FVC2004 指紋資料集進行系統性能測試，透過不同比對演算法如 Minutia 與 FLANN 的比較，驗證了系統在準確性與運行效率上的表現。實驗結 果顯示在模組化設計下，各模組的獨立性和可靠性得到了充分驗證。大型語言 模型在程式碼生成中的應用，提升了開發效率並降低人為錯誤的風險。此研究 不僅對於指紋辨識技術的進一步發展具有啟發性，也提供了一種創新的系統設 計方法，適用於其他高複雜度的軟體開發領域。

關鍵字：指紋比對；MIAT 方法論：離散事件建模；高階合成；大型語言模型 (LLM)

This research uses a fingerprint feature matching system as a validation case to

explore system design and high-level synthesis methods that combine MIAT methodology with Large Language Models (LLMs). The MIAT methodology focuses on hierarchical modular architecture design and discrete event modeling of algorithms, ultimately synthesizing maintainable and scalable system code. In the final stage of the methodology, we introduce LLMs to generate the necessary code driven by each discrete event state. To validate this approach, we designed hierarchical modules for the fingerprint feature matching system, including rotation elimination module, segment direction elimination module, and feature matching module. For experimentation, we conducted system performance testing based on the FVC2004 fingerprint dataset, comparing different matching algorithms such as Minutia and FLANN to validate the system's performance in terms of accuracy and operational efficiency. The experimental results demonstrated that under the modular design, the independence and reliability of each module were thoroughly validated. The application of LLMs in code generation improved development efficiency and reduced the risk of human error. This research not only provides insights for further development of fingerprint recognition technology but also offers an innovative system design method applicable to other complex software development domains.

本論文之完成，首先衷心感謝恩師慶瀚教授的悉心指導與鼓勵。碩士期 間，從文獻的探討、研究方向的選擇、觀念架構之建立、實驗方法的設計，以 迄本文之撰寫，吾師不斷地予以指導與啟迪，更對初稿逐字斧正，使得本論文 得以順利完成，師恩浩瀚，永銘五內。此外，慶瀚教授開設的嵌入式系統設計 課程讓我受益良多，課程內容層層深入，清楚闡述方法論，使我在研究過程中 獲得寶貴的知識與啟發。承蒙口試老師林明義教授、謝昇憲教授許多寶貴的建 議與指正，謹致以最深的謝意。

同時，我也要感謝彥廷同學與如珊同學，在最後口試前匆忙的日子裡，彼 此相互督促與鼓勵，共同努力完成論文。

當然，我的雙親與家人的鼓勵與支持是功不可沒的。尤其是在撰寫論文最 後階段的晨昏顛倒、日以繼夜的日子裡，沒有他們的悉心照料與打氣，我肯定 是無法撐過去的。衷心感謝他們無所求的付出

中文摘要............................................................ i

Abstract ............................................................ ii

目錄............................................................... iv

圖目錄............................................................ vii

表目錄............................................................. ix

第一章、 緒論.................................................... 1

第二章、 指紋比對技術回顧........................................ 4

第三章、 可重構指紋特徵比對系統設計............................. 25

MIAT 方法論 .............................................. 25

IDEF0 階層式模組化設計 ............................................................ 26

Grafcet 離散事件建模 ................................................................... 27

3.3 可重構指紋特徵比對系統架構設計 ........................... 31

3.4 離散事件建模 ............................................. 36

第四章、 可重構指紋特徵比對實驗................................. 41

4.1 實驗環境 ................................................. 41

4.2 資料描述 ................................................. 41

4.3 基於 LLM 的 Grafcet 框架生成方法：實驗與應用分析 ........... 43

4.4 可重構指紋特徵比對驗證 ................................... 49

FLANN 比對實驗 .......................................................................... 54

4.5 結果比較 ................................................. 57

4.6 實驗結果分析 ............................................. 60

第五章、 結論................................................... 61

參考文獻........................................................... 63

附錄一 生成 Grafcet 對話流程......................................... 72

附錄二 可重構指紋比對 Grafcet Action ................................. 75

## 圖目錄

圖 3.9 線段方向排除模組(A42) ................................................................................ 34

圖 3.10 特徵點比對模組(A43) .................................................................................. 35

圖 3.11 指紋辨識系統離散事件建模........................................................................ 36

圖 3.12 指紋比對離散事件建模................................................................................ 37

附圖 3 生成對應的程式碼.......................................................................................... 73

附圖 4 子系統邏輯敘述確認...................................................................................... 73

附圖 5 結合子系統與主架構程式............................................................................. 74

**📊 表格內容：**

<table><tbody><tr><td>硼 4.1 實驗 環境 規格</td><td>41</td></tr><tr><td colspan="2">表 4.2 FVYC2004 資料 集 說 明 ,, 42</td></tr><tr><td colspan="2">表 4.3 Minutia 比 對 實驗 結果 紀錄 ,,,, eceeecseceeeeecseeeeecseseeeeesesesseaeseseseaeeeseeecaeeeeesees 53</td></tr><tr><td>#&amp; 4.4 FLANN Matching $f 544 SSSR oo</td><td>ceccccccescescesceccsscesececsecsacesssssecseesecsseesesees 57</td></tr></tbody></table>

表 4.1 實驗環境規格 ................................................................................................ 41

表 4.2 FVC2004 資料集說明 ................................................................................... 42

表 4.3 Minutia 比對實驗結果紀錄........................................................................... 53

表 4.4 FLANN Matching 實驗結果紀錄.................................................................. 57

## 1.1 研究背景

指紋辨識技術作為一種基於生物特徵的安全驗證方法，憑藉其唯一性、穩定 性和便捷性[1]，廣泛應用於金融交易、智慧設備解鎖以及邊境管制等多個領域 [2]，可以通過指紋比對來進行身份認證和識別來保護個人財產及私人訊息[3]。

然而，隨著大規模數據處理需求的增加以及應用場景的多樣化，指紋辨識系統面

臨了效率與準確性兼顧的挑戰。

為了提高指紋比對的效率和準確性，近年來，研究人員開始探索自動化指紋 比對技術。隨著計算機視覺、機器學習等技術的不斷發展，自動化指紋比對技術 也在不斷進步[4]。目前指紋比對技術已經實現了高度自動化，可以在數秒內完成 大量的指紋比對且準確率高[5]。

指紋比對是通過比較待辨識與數據庫中的指紋特徵，判斷是否為同一個人的 過程。常用的指紋比對演算法包括 Qi 與 Zhao 等人使用 Hough Transform 來進行 指紋特徵比對[6]和 Lee 和 Choi 提出區域性對齊比對演算法來降低指紋影象因指 紋扭轉和牽引造成變形而產生非線性變形的參數[7]。

指紋比對系統需處理龐大的數據量，包括已紀錄和待辨識的指紋資料，並進 行複雜運算。由於這些數據量非常龐大，因此需要進行高效的存儲和管理方式[8]。 為了提高指紋比對效率，Peralta、García、Benitez 與 Herrera 提出了一種指紋比 對分解方法[9]，即將指紋圖像分解為多個小區域，然後對每個小區域進行指紋比 對，該方法使用了 Apache Hadoop 和 Apache Spark 分散式叢集架構，系統只需定 義區域性結構和聚合函數，即可達到良好的可擴展性和高效性。該研究進一步驗 證了系統框架的優越性。

在軟體開發層面，系統設計的複雜性也給開發效率與維護性帶來了壓力[10]。 傳統系統設計方法難以有效應對功能模組的快速擴展和升級需求，特別是在面對 高複雜度的生物辨識系統時。MIAT 方法論的引入為此提供了一種有效解決方案。 該方法論以階層式模組化為核心，通過將系統分解為易於管理的小型模組，實現 功能模組的高獨立性與易擴展性。

此外，人工智慧技術的快速發展，特別是大型語言模型(LLMs)(如 ChatGPT) 在程式碼生成方面展現了令人印象深刻的效能。通過分步進行程式碼生成，可以 逐步引導 LLMs 分析和實現程式邏輯，從而提高程式碼的正確性、品質和可維護 性。這些模型將自然語言提示轉換為可執行程式碼的能力，對軟體開發實踐產生 重大影響，顯著減少手動編碼工作和人為錯誤的可能性[11]。

## 1.2 研究動機與目的

系統架構的設計和優化變得越來越重要，本研究提出了一種基於模組化的指 紋特徵比對系統設計方法，並結合大型語言模型(LLMs)在自動生成程式方面的 卓越能力[12]。這種方法能幫助系統開發人員更高效地進行開發和維護。

本論文首先將針對指紋特徵比對系統進行研究，探討系統架構模組化的設計 思路和好處。模組化的系統架構使得不同模組之間相互獨立，可以單獨維護和更 新，而不影響整個系統的運行[13]。當需要增加新功能或修改現有功能時，只需 針對相應模組進行修改，無需重構整個系統[14]，從而大幅簡化開發和維護工作。 這樣可以提高系統的可靠性和穩定性，減少系統故障對用戶帶來的影響。模組化 的系統架構也可以讓不同的開發人員專注於不同的功能模組開發，提高開發效率 [15]。然而，模組之間的接口定義清晰，不同開發人員可以獨立開發並協作完成， 提高效率[16]。此外，模組化設計支持模組重用，減少開發時間和成本，縮短軟 體開發生命週期。

MIAT 方法論強調階層式模組化設計，提供了將複雜功能分解為易於管理 的模組化解決方案的可能性。同時，人工智慧技術的快速進步，大型語言模型 進行程式碼生成可以顯著提高程式碼的準確性和開發效率，同時降低人為錯誤 和安全漏洞的風險，從而大幅提升軟體開發的質量和效率[17]。

基於此，本研究旨在結合 MIAT 方法論與大型語言模型，開發一套創新的高

效系統設計框架，並以指紋特徵比對系統作為驗證案例，透過不同比對演算法如 Minutia 與 FLANN 的比較，探討這種方法在高複雜度軟體開發中的應用價值。 研究目標包括驗證模組化設計在提升系統獨立性與可靠性方面的效果，探索大型 語言模型在程式碼生成中對開發效率和準確性的貢獻，評估結合 MIAT 與 LLM 方法後系統在準確性與運行效率上的整體性能，並進一步分析該設計框架在其他 高複雜度軟體開發場景中的適用性。本研究期待能在指紋辨識技術的應用以及系 統設計理論的拓展方面實現突破，為未來相關領域的研究與實踐提供有價值的創 新思維。

## 1.3 研究架構

本研究以結合 MIAT 方法論與大型語言模型(LLMs)的創新系統設計方法為 核心，旨在探討其在指紋特徵比對系統開發中的應用價值。整體架構採用系統性 的方法，從設計理論到實驗驗證，逐步揭示該方法的潛在優勢與挑戰。

此研究架構分為五章節，第一章緒論說明研究背景、動機與目的，並介紹研 究架構。第二章為回顧與此指紋比對有關的現行技術的參考文獻。第三章細說研 究方法，使用 MIAT 方法論設計流程、程式碼生成方法以及實驗設計的具體步 驟。第四章為系統高階合成，主要為驗證整合 MIAT 方法論與大型語言模型於系 統設計，並以指紋比對系統為案例研究，展示並分析系統性能測試結果。第五章 為回顧研究結果與本實驗貢獻，並提出在研究中所遇到的限制與未來研究方向。

## 第二章、 指紋比對技術回顧

指紋比對因其各種特徵而流行，例如：易於收集資料，易於訪問眾多來源， 且十根手指可用於收集。指紋的使用有十九世紀的記錄，弗朗西斯·高爾頓爵士 定義了指紋的特徵點，這些特徵點被稱為高爾頓點(Galton points)，且高爾頓點亦 是建立指紋識別系統的基礎，高爾頓點的子集用於表示指紋影像，這些被稱為特 徵點(Minutia)[18]。

## 2.1 指紋特徵

指紋特徵中，脊線呈現為黑色線條，相反之谷地則呈現為脊線之間的白色區 域[19]。指紋特徵大致可分為三類，分別為全域特徵、局部特徵、次級特徵，這 些特徵在指紋識別系統中扮演著重要角色。

全域特徵提供了指紋的基本形狀訊息，局部特徵則提供了詳細的識別訊息， 而次級特徵在高精度識別中發揮重要作用。通過結合這些特徵，可以有效地提高 指紋識別的準確性和穩定性[20]。

## 2.1.1 全域特徵

全域特徵是指紋圖像中最直觀的特徵，這些特徵描述了指紋的整體形狀和 紋理結構。它們在指紋識別的初步分類階段中起著至關重要的作用，因為它們能 夠迅速將指紋分類為幾個基本類型，從而減少比對的搜尋範圍。

其中特徵形成了一種特殊的脊線和谷地圖案，稱為奇異點或單點(Singular Points)[21]，可進一步分為三種類型：環狀、三角和螺旋。重要的是核心點及三 角點。核心點被定義為最內側脊線上的最重要點，而三角點則被定義為三種不同

趨勢流匯聚的中心點如圖 2.1 所示。因此，這些特徵為指紋分類、指紋比對和指 紋對齊提供了有用和關鍵的訊息[22][23]。

---

![圖片：figure-15-1.jpg](images/figure-15-1.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體解讀：**

這張圖（圖2.1）展示的是指紋中的兩種重要局部特徵：**核心 (Core)** 和 **三角奇異點 (Delta/Trifurcation)**。 這些特徵是進行指紋分類、比對和對齊的關鍵訊息來源。

**詳細分析：**

*   **圖片內容：**
    *   圖片呈現了一張指紋局部放大圖，可以清晰看到指紋線條的彎曲和流向。
    *   圖片中用紅色方框標出了兩個特徵點，並用箭頭指向它們：
        *   **核心 (Core)：** 指紋線條環繞或旋轉的中心區域。在圖片中，核心位於指紋圖案的中央偏右位置，呈現出螺旋狀結構。
        *   **三角奇異點 (Delta/Trifurcation)：** 指紋線條分叉或匯聚的三個方向。在圖片中，三角奇異點位於指紋圖案的左下方，可以觀察到三條線條從該點發散。

*   **前後文關聯：**
    *   **上下文文字 (前)：** 說明這些特徵（如核心和三角奇異點）是“趨勢流匯聚的中心點”，並且對於指紋分類、比對和對齊至關重要，並引用了相關研究[22][23]。這句話強調了圖片中展示的特徵的重要性。
    *   **上下文文字 (後)：** 標明圖2.1是關於“Minutia 類型-核心和三角形奇異點”的說明，並且將其歸類為“局部特徵”。這句話明確了圖片內容的主題：指紋中的局部特徵及其具體類型。

**結論：**

總而言之，這張圖2.1是為了闡述指紋分析中重要的局部特徵——核心和三角奇異點。它展示了這些特徵在指紋圖像中的視覺表現，並與前後文文字相結合，說明了它們在指紋識別技術中的作用和意義。 圖片的目的是幫助讀者理解這些特徵的外觀以及它們在指紋分析流程中的重要性。

---

圖 2.1 Minutia 類型-核心和三角形奇異點

## 2.1.2 局部特徵

在局部層面上，稱為細節特徵的脊線特徵是用於指紋比對的最廣泛使用的 特徵。雖然細節特徵有幾種類型，主要考量兩種類型的細節特徵[24][25]，這兩 種是最突出的脊線特徵：脊線末端指的是脊線突然終止的點，如圖 2.2 (a)所示， 脊線分叉指的是脊線分岔或分散成分支脊線的點，如圖 2.2(b)所示。

---

![圖片：figure-15-2.jpg](images/figure-15-2.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 根據提供的前後文以及圖片內容，我對該圖片的專業解釋如下：

**圖片主題：脊線末端 (Ridge Ending)**

這張圖2.2(a) 展示的是指紋中的一種局部特徵，稱為「脊線末端」。

*   **上下文說明:** 文件提到在指紋比對中，細節特徵（脊線特徵）是最常用的。其中，脊線末端和脊線分叉是兩種最突出的類型。
*   **圖片內容分析:** 圖片清晰地顯示了灰色的指紋脊線，以及用紅色標記的「脊線末端」。紅色部分代表一條脊線突然終止的點，也就是脊線在某處結束，不再繼續延伸。

**總結：**

這張圖是為了說明和定義指紋比對中重要的局部特徵之一——脊線末端。它通過視覺化的方式，讓讀者更容易理解脊線末端的具體形態，即脊線突然終止的點。圖片中的 (a) 標註也表明這是圖2.2的第一個子圖，可能接下來會展示另一種重要的局部特徵：脊線分叉。

---

---

![圖片：figure-15-3.jpg](images/figure-15-3.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 根據提供的前後文以及圖片內容，我對該圖片的專業解釋如下：

**圖片所表達的內容是「脊線分叉」這一種細節特徵。**

具體分析：

*   **上下文關聯:** 前文提到指紋比對中常用的細節特徵之一是脊線特徵，並特別指出兩種最突出的類型：脊線末端和脊線分叉。圖片後面的文字標註為(b)，暗示此圖為第二種特徵的示意圖。
*   **圖片內容:** 圖片顯示了多條灰色的脊線，其中一條紅色的脊線突然分岔成兩條分支脊線。這與前文對「脊線分叉」的描述完全吻合：「脊線分岔指的是脊線分岔或分散成分支脊線的點」。
*   **總結:** 因此，可以確定圖片是為了說明和解釋指紋比對中「脊線分叉」這一細節特徵而存在的。紅色標註突顯了脊線分岔的位置，方便讀者理解該特徵的形態。

簡而言之，這張圖是關於指紋識別技術中，脊線特徵的一種——脊線分叉的視覺化呈現。

---

圖 2.2 Minutia 類型： (a) 山脊末端 (b) 山脊分岔

## 2.1.3 次級特徵

指紋特徵的次級特徵是指在主要特徵的脊線終點和分叉點之外更細微且更 具體的特徵，這些次級特徵在指紋比對和識別過程中也起著重要作用。以下是一 些常見的次級特徵[26]：

* 1. 脊線方向

每個脊線的方向[27]，包括脊線的起點方向、終點方向以及脊線的整體 走向如圖 2.3 所示。由特徵點定義為中心，從特徵點延伸出一條垂直軸，並 且垂直於所有指紋線條結構，而此脊線垂直軸可以克服扭曲的指紋圖片。

---

![圖片：figure-16-4.jpg](images/figure-16-4.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體解讀：**

這張圖（圖2.3）是為了說明指紋中的「脊線」概念，以及如何定義和提取脊線的方向。圖片展示了一張指紋圖像，並在其中標示出一個特徵點以及從該特徵點延伸出的脊線。

**詳細分析：**

1. **指紋圖像：** 圖片中心是典型的指紋圖像，由多條彎曲的脊線組成。這些脊線代表了指紋的主要結構。
2. **特徵點 (紅色圓點)：**  圖片中用一個紅色圓點標示出一個「特徵點」。根據上下文，這個特徵點是定義脊線方向的中心點。
3. **脊線 (藍色粗線)：** 從特徵點延伸出的藍色粗線代表一條「脊線」。這條線並非直線，而是彎曲的，反映了指紋脊線的實際形狀。
4. **脊線方向：** 上下文文字強調，脊線的方向包括起點方向、終點方向和整體走向。圖片中的藍色粗線可以視為描述該特徵點周圍脊線的整體走向。
5. **垂直軸的作用：**  上下文提到「從特徵點延伸出一條垂直軸，並且垂直於所有指紋線條結構」，這意味著雖然圖片中只畫出了一條彎曲的脊線，但實際上可以想像一條通過該特徵點且垂直於周圍指紋線條的軸。這個垂直軸有助於克服扭曲指紋圖像的問題，更準確地提取脊線方向信息。

**總結：**

這張圖片是為了配合「脊線方向」的定義進行視覺化的說明。它展示了如何從指紋圖像中選取特徵點，並以此為中心描述脊線的走向。藍色粗線代表一條脊線，而通過該特徵點的垂直軸則用於更準確地提取脊線的方向信息，尤其是在處理扭曲的指紋圖像時。圖片後面的「脊線數量」暗示了接下來將會討論如何計算或分析指紋中的脊線數量。

---

* 2. 脊線數量

脊線數量[26](Ridge Count)是透過計算沿垂直軸的脊數來計算的，直到 軸與附著的脊相遇。脊線數量的定義是垂直軸經過的山脊數量。如果已經包 含的脊線或脊線沒有附加的特徵點時，則不會新增脊線數量，而兩特徵點(u、 v)之間的脊線數量，如圖 2.4 所示。

---

![圖片：figure-17-5.jpg](images/figure-17-5.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## Grafcet 流程圖文字描述：脊線數量計算

此 Grafcet 流程圖描述了如何根據特徵點 u 和 v 計算脊線數量。

**初始步驟 (Step 1 - 雙線方塊)：**系統處於待機狀態，等待開始計算脊線數量。

**流程演進：**

從初始步驟出發，流程進入 Step 2。

**Step 2：**檢查特徵點 u 和 v 是否存在。如果不存在，則保持在 Step 2 狀態。

**Step 3：**判斷特徵點 u 和 v 的連接方式。此處出現分支結構，根據 Grafcet 規則總綱第4條的判斷，由於橫線之前沒有共通的轉移條件，因此這是一個**選擇性分支**。

* **分支一 (a)：**如果特徵點 u 和 v 以特定方式連接（如圖2.4(a)所示），則流程進入 Step 4A。
    * **Step 4A：**計算脊線數量為 2。
    * **Step 5A：**輸出脊線數量結果 (2)。
    * **Step 6A：**返回初始步驟 (Step 1)，等待下一次計算。

* **分支二 (b)：**如果特徵點 u 和 v 以另一種方式連接（如圖2.4(b)所示），則流程進入 Step 4B。
    * **Step 4B：**計算脊線數量為 1。
    * **Step 5B：**輸出脊線數量結果 (1)。
    * **Step 6B：**返回初始步驟 (Step 1)，等待下一次計算。

**循環說明：**

系統從初始步驟開始，檢查特徵點是否存在，然後根據特徵點的連接方式選擇不同的分支進行計算。無論哪個分支被執行，最終都會輸出脊線數量結果並返回初始步驟，形成一個完整的循環，可以持續計算不同特徵點組合的脊線數量。

**總結：**

此流程圖實現了一個基於特徵點連接方式判斷脊線數量的自動化控制邏輯。它通過選擇性分支處理不同的連接情況，確保了正確的脊線數量計算結果。

---

圖 2.4 (a)脊線數量為 2 (b)脊線數量為 1

脊線的彎曲程度即為脊線曲率[28]，為了在脊線模式中使用更多資訊進行 比對，需考慮脊線曲率方向(Ridge Curvature Direction)。這是因為即使脊線數 量和脊線長度值非常相似，脊線圖案的形狀也可能不同。例如，有兩條曲線的 長度相同，但一條是凹形，另一條是凸形，如圖 2.5 所示。如果只考慮曲線的 長度，就無法區分曲線，因此在這種情況下，如果需要納入曲率方向，才可以 分辨出它們是不同的。

---

![圖片：figure-17-6.jpg](images/figure-17-6.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體說明:**

這張圖2.5旨在闡述脊線曲率方向的重要性，以及為何在脊線模式比對中需要考慮這個因素。它通過兩個例子展示了即使兩條曲線長度相同，形狀也可能因曲率方向不同而有所差異。

**詳細分析：**

*   **圖例說明:**
    *   **(a) 凹形:** 圖中的藍色實線代表脊線，紅色虛線表示一條與脊線平行的輔助曲線。在(a)圖中，輔助曲線呈現凹陷的形狀，因此標記為“凹形”。箭頭 u 和 v 表示曲率方向，指向凹陷的中心。
    *   **(b) 凸形:** 圖中的藍色實線同樣代表脊線，紅色虛線表示一條與脊線平行的輔助曲線。在(b)圖中，輔助曲線呈現凸起的形狀，因此標記為“凸形”。箭頭 u 和 v 表示曲率方向，指向凸起的中心。

*   **核心概念：脊線曲率方向:**
    *   上下文文字強調，僅考慮脊線的長度不足以區分不同的脊線圖案。例如，兩條相同長度的曲線，一條凹形、一條凸形，在只考慮長度的情況下會被視為相同的模式。
    *   通過引入“脊線曲率方向”的概念，可以有效地區分這些具有相同長度但不同形狀的脊線。

*   **箭頭的作用:**
    *   箭頭 u 和 v 標示了曲線的曲率中心方向。凹形的箭頭指向內側，凸形的箭頭指向外側。這種方向性的信息是區分不同脊線圖案的重要依據。

**總結：**

這張圖片配合上下文文字，清晰地說明了在進行脊線模式比對時，除了考慮脊線的數量和長度之外，還必須納入“脊線曲率方向”這一重要因素。通過判斷脊線是凹形還是凸形，可以更準確地區分不同的脊線圖案，提高比對的準確性。

---

圖 2.5 脊線曲率方向 (a)凹形 (b)凸形

## 2.2 指紋比對演算法

指紋比對在驗證和辨識問題中是一個至關重要的步驟[29]。該算法通常比較 兩個指紋圖像，並回傳一個實數區間的相似度或二元輸出(比對成功或比對失敗)。 指紋比對模組計算兩個指紋之間的比對分數時，來自同一手指的指紋應該很高， 而來自不同手指的指紋應該很低[30]。但現實往往不是，許多因素使指紋比對為 一個困難的問題：其中圖像雜訊、皮膚狀況、扭曲、旋轉、位移等等，造成同一 手指的不同影像之間具有很大的差異，然而另一個為來自不同手指的兩個圖像 之間具有很大的相似性[31]。

大多數指紋比對演算法採用四種方法之一[30]：Image correlation 演算法比 對、Phase 演算法比對、Skeleton 演算法比對和 Minutia 演算法比對。其中最廣泛 的技術是 Minutia 的比對。

在過去的二十年中，已有多種機器學習和深度學習方法應用於指紋分類，指

紋分類方法需要使用機器學習、深度學習以及仿生模型等預處理技術，以提高指 紋分類的準確性[32]。指紋分類演算法在減少指紋識別系統的搜尋時間和計算複 雜度方面非常重要[33]。隨著科技進步，傳統的指紋識別系統易受假指紋攻擊， 導致安全問題，因此在 Liu 與 Li 等人研究[34]使用 FLANN(Fast Library for Approximate Nearest Neighbors)演算法，擷取測試的內部指紋特徵點並比對指紋 特徵集來以認證身份，與傳統算法相比，這種方法難以模仿，且具有較高的安全 性。在 Mishra 與 Dehuri[35]的實驗中使用粒子群演算法(Particle Swarm Optimization)連結 FLANN 在真實收集的指紋中，透過提出的 FLANN-PSO 演算 法，在不同參數和指紋的不同角度特徵測試其準確性，並獲得了 98%的準確率， 準確性和均方誤差(MSE)方面的結果顯示出相較於其他算法的顯著改善。

接下來的小節將詳細介紹各指紋比對的主要概念。指紋比對過程分為兩個 部分：特徵擷取和比較。比對的部分是指將一個指紋圖像與另一個指紋圖像進

行比較以確定它們是否相同的過程。比對原理是基於指紋圖像中的紋理特徵進 行比較，通過將兩個指紋圖像的紋理特徵進行對齊，然後比較它們之間的差異 程度來確定它們是否配對成功。一般會使用指紋辨識演算法將指紋圖像轉換為 數據表示，並且將數據進行比較，以確定它們是否相同。

## 2.2.1

Image correlation 演算法比對

影像比對是指在同一場景下，比對兩張或多張影像的幾何關係的過程。這些 影像可以在不同時間、不同角度或使用不同成像感測器所獲得。通過比對影像的 共同特徵，識別並比對它們之間的相似性，從而進行影像配對[36]。其通常是用 於圖形識別、圖形比對、目標跟蹤等應用領域。

一般而言，相關方法是一種可以顯示變量對(Pairs of variables)之間相關性強 度的技術，以結果的相關係數值來表示，範圍從-1.0 到+1.0，接近+1 的範圍表示 一個變量與另一個變量之間的關係越密切。它在圖形識別中展示了良好的應用 效果。其中，正規化交叉相關比對法(Normalized Cross Correlation)廣泛應用於機 器視覺的工業檢測，包括複雜圖像中的瑕疵檢測。

Insankeovilay 與 Prasarn [37]研究中，設 f 為測試圖像(來源圖像)，t 為樣本 圖像，透過尋找樣本圖像 t 與測試圖像 f 任何部分的相似性。在這種情況下， 圖像 t 的大小小於或等於 f 時。測量相似性或不匹配的一種簡單方法是對特定 區域內的樣本圖像 t 和測試圖像 f 取絕對差，如下圖 2.6 所示。

---

![圖片：figure-20-7.jpg](images/figure-20-7.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容。

**總體理解：**

這張圖（圖2.6）展示了圖像匹配的一個基本步驟，即將一個較小的樣本圖像 `t` 在一個較大的來源圖像 `f` 中尋找相似區域的過程。上下文描述的是 Insankeovilay 與 Prasarn [37] 的研究方法，核心思想是通過計算樣本圖像與來源圖像不同區域之間的絕對差來衡量相似度。

**圖片細節分析：**

*   **兩個矩形框：**
    *   左側的矩形框標記為“樣本圖像”，大小為 `Nx` x `Ny`，中心點用黃色圓圈標示。 矩形框內有網格線，表示圖像被劃分為小的單元。
    *   右側的矩形框標記為“來源圖像”，大小為 `Mx` x `My`，中心點也用黃色圓圈標示。同樣有網格線。
*   **座標系統：**
    *   樣本圖像使用座標 `x, y` 表示其內部位置。
    *   來源圖像使用座標 `u, v` 表示其內部位置。
*   **紅色箭頭和公式 `f_{x,y}`：**
    *   紅色箭頭表示將樣本圖像的每個像素點對應到來源圖像上的位置。
    *   `f_{x,y}` 是一個函數，代表在來源圖像中，座標為 (u, v) 的像素值與樣本圖像中座標為 (x, y) 的像素值的絕對差。換句話說，這個公式描述了樣本圖像的每個像素點與來源圖像上對應位置像素點之間的差異。
*   **實驗步驟：**
    *   上下文提到，實驗將比較來源圖像 `f`（測試圖像）和樣本圖像 `t`（數據庫）。圖2.6 描繪的就是這個比較過程的第一步：找到樣本圖像在來源圖像中的對應位置。

**前後文的關聯：**

*   上下文說明了“尋找樣本圖像 t 與測試圖像 f 任何部分的相似性”，而這張圖片正是展示了如何實現這種尋找，即通過計算絕對差來衡量相似度。
*   上下文提到“圖像 t 的大小小於或等於 f 時”，圖片也體現了這個條件：樣本圖像明顯比來源圖像小。
*   後文提到實驗步驟分為三個，圖2.6 描繪的是第一個比較步驟。

**總結：**

這張圖片是圖像匹配算法中的一個關鍵步驟示意圖，它展示了如何將一個較小的樣本圖像在一個較大的來源圖像中進行定位和比較。通過計算樣本圖像與來源圖像不同區域的像素值絕對差，可以衡量它們之間的相似度，從而找到最佳匹配位置。這張圖片配合上下文文字，完整地解釋了 Insankeovilay 與 Prasarn [37] 研究方法中的圖像匹配過程的第一步。

---

圖 2.6 將樣本圖像 t 對應到來源圖像 f

實驗中來源圖像 f(測試圖像)與樣本圖像 t(數據庫)的比較步驟分為三個：

* 1. 將兩個圖像裁剪成 128x128 像素大小(核心點位於中心)。

* 2. 將每個圖像分成 4 個子圖像，每個子圖像為 64x64 像素。

* 3. 使用 NCC 樣本來比對相應的子圖像。每個區域的比對分數相加，分 數高於設定值(閾值)的圖像則比對成功。

其 NCC 比對相關說明如下：

樣本圖像 t 和來源圖像 f 在每個維度上偏移 u 和 v 的區域進行差異平方和 的計算，因此可以得到以下公式(2.1)：

2 (𝑢,𝑣) = ∑[𝑓(𝑥,𝑦) − 𝑡(𝑥 − 𝑢,𝑦 − 𝑣)]2 𝑑𝑓,𝑡 𝑥,𝑦 (2.1)

從上述公式延伸出公式(2.2)：

2 (𝑢,𝑣) = ∑[ 𝑑𝑓,𝑡 𝑥,𝑦 𝑓2(𝑥,𝑦) − 2𝑓(𝑥,𝑦)𝑡(𝑥 − 𝑢,𝑦 − 𝑣) +𝑡2(𝑥 − 𝑢,𝑦 − 𝑣) ] (2.2)

而∑ [𝑡2(𝑥 − 𝑢,𝑦 − 𝑣)] 𝑥,𝑦 因為從樣本圖像來，所以是固定值，且 ∑ [𝑓2(𝑥,𝑦)] 也是固定的。

因此相似性的交叉相關公式表示為：

𝑐(𝑢,𝑣) = ∑[𝑓(𝑥,𝑦)𝑡(𝑥 − 𝑢,𝑦 − 𝑣)] (2.3) 𝑥,𝑦

然而直接使用公式(2.3)會導致圖像強度可能在不同區域間變化的問題，而

使獲得的結果不一致。為避免此類問題，需考慮均值(means)和方差

(variances)，因此定義公式(2.4)稱為正規化交叉相關(NCC)。

正規化交叉相關公式：

𝛾(𝑢,𝑣) = ∑[𝑓(𝑥,𝑦) − 𝑓̅ 𝑢,𝑣][𝑡(𝑥 − 𝑢,𝑦 − 𝑣) − 𝑡̅] (2.4) √∑ [𝑓(𝑥,𝑦) − 𝑓̅ 𝑥,𝑦 𝑢,𝑣]2 ∑ [𝑡(𝑥 − 𝑢,𝑦 − 𝑣) − 𝑡̅]2 𝑥,𝑦

𝑢,𝑣與𝑡̅分別表示為：

𝑓̅ 𝑢,𝑣 = 1 𝑁𝑥𝑁𝑦 𝑢+𝑁𝑥−1 𝑣+𝑁𝑦−1 ∑ ∑ 𝑓(𝑥,𝑦) 𝑥=𝑢 𝑦=𝑣 𝑡̅ = 1 𝑁𝑥𝑁𝑦 𝑢+𝑁𝑥−1 𝑣+𝑁𝑦−1 ∑ ∑ 𝑡(𝑥,𝑦) 𝑥=𝑢 𝑦=𝑣

簡單來說，圖像相關比對是指將兩個指紋圖像進行重疊，通過比較不同對 齊方式下對應像素的相關性來計算它們之間的相似度。當比對區域相對較小 時，圖像相關比對能夠提供良好的計算效果，但這種技術會消耗大量的存儲和 計算資源。然而，相關性比對的往往較難以獲得理想的結果，主要是由於圖像 的全局結構、亮度和對比度發生了不良的變化，而這些變化通常取決於指紋的 扭曲和皮膚狀態[31]。

## 2.2.2 Phase 演算法比對

典型的指紋識別方法採用基於特徵的影像比對，從註冊的指紋影像和輸入

指紋影像中擷取特徵，主要為指紋脊末端和指紋脊分岔，並通過對比這些特徵在 兩幅圖像中對應的特徵點數量來識別有效的指紋圖像[38]。然而，由於特殊的面 板條件，一些人無法透過基於特徵的方法識別指紋，因為影像處理很難擷取特徵 點。擁有如此困難指紋的人的比例因種族、性別、年齡、工作組合等而異，但佔 總人口的百分之一到百分之五可能屬於這一類別。為了解決這個問題，Ito、Morita、 Aoki[39]等人提出了一種使用基於相位的影像比對的高效指紋識別演算法，使用 給定影像的二維離散傅立葉變換(Discrete Fourier Transforms)中的相位分量的影 像比對技術。其相位相關函式(Phase-correlation function)的相位影像比對的演算 法，由四個步驟組成分別為核心檢測、旋轉和位移對齊、公共區域擷取和、指紋

比對，如圖 2.7 所示。

## 圖 2.7 相位比對流程圖

首先先將註冊指紋影像𝑓(𝑛1,𝑛2)和輸入指紋影像𝑔(𝑛1,𝑛2)對齊兩個影像，接 著對兩指紋進行旋轉和位移。在兩個指紋影像都有核心的情況下，使用核心的位 置對齊指紋影像之間的平移位移，在角度範圍為−40° ≤ 𝜃 ≤ 40°且角度間隔為1° 的情況下，對於已註冊的指紋影像𝑓(𝑛1,𝑛2)，計算其旋轉後的影像𝑓𝜃(𝑛1,𝑛2)的 BLPOC(Band-Limited Phase-Only Correlation)值，其中影像旋轉採用雙三次插值法 (bicubic interpolation)。通過評估旋轉後的已註冊影像𝑓𝜃(𝑛1,𝑛2)(−40° ≤ 𝜃 ≤ 40°)與 輸入影像𝑔(𝑛1,𝑛2)之間的相似性，可以確定輸入影像相對於註冊影像的旋轉角度 𝜃。

但當𝑓(𝑛1,𝑛2)或𝑔(𝑛1,𝑛2)中有一者缺少其核心時，使用上述方法對旋轉進行 正規化。接下來，對旋轉正規化(Rotation-normalized)的圖像𝑓𝜃(𝑛1,𝑛2)和輸入圖像 𝑔(𝑛1,𝑛2)進行平移位移。平移位移可以通過𝑔(𝑛1,𝑛2)和𝑔(𝑛1,𝑛2)之間的 POC 函 數(Phase-Only Correlation function)的峰值位置獲得。將獲得已正規化的註冊圖像和

輸入圖像，分別表示為 𝑓′(𝑛1,𝑛2)和𝑔′(𝑛1,𝑛2)。

接下來的步驟是擷取兩幅圖像𝑓′(𝑛1,𝑛2)和𝑔′(𝑛1,𝑛2)的重疊區域。此過程提

高了指紋比對的準確性，因為兩幅圖像的非重疊區域會成為 BLPOC 函數中的不 相關雜訊成分。為了檢測已註冊圖像𝑓′(𝑛1,𝑛2)和輸入圖像𝑔′(𝑛1,𝑛2)中的有效指 紋區域，因此檢查的𝑛1軸突出畫素值和𝑛2軸突出畫素值，只有相同大小的公共有 效圖像區域𝑓′′(𝑛1,𝑛2)和𝑔′′(𝑛1,𝑛2)會被擷取，用於後續的圖像比對步驟。最後計 算兩個擷取出的圖像𝑓′′(𝑛1,𝑛2)和𝑔′′(𝑛1,𝑛2)之間的 BLPOC 函數𝑟𝑓′′𝑔′′ 𝐾1𝐾2(𝑛1,𝑛2)，並 評估比對分數。由於彈性指紋變形可能會產生多個相關峰值，因此定義兩個圖像 之間的比對相似度分數為 BLPOC 函數𝑟𝑓′′𝑔′′ 𝐾1𝐾2(𝑛1,𝑛2)的最高兩個峰值之和，如公 式(2.5)。

比對相似度分數其計算公式如下：

𝐾1𝐾2(𝑛1,𝑛2) = 𝑟𝑓𝑔 1 𝐿1𝐿2 ′ ∑ 𝑅𝐹𝐺(𝐾1,𝐾2) 𝐾1,𝐾2 −𝑘1𝑛1𝑊𝐿2 −𝑘2𝑛2 × 𝑊𝐿1 (2.5)

𝑛1 = −𝐾1 …𝐾1,𝑛2 = −𝐾2 …𝐾2

∑′ 𝐾1,𝐾2 表示∑ 𝐾1 𝑘1=−𝐾1 ∑𝐾2 𝑘2=−𝐾2

## 2.2.3 Skeleton 演算法比對

骨架化(skeletonization)是用於增強比對的一個常見工具，在電腦視覺和影像 辨識中用於比對骨架或中軸表示的形狀的技術。物體的骨架是物體的一個較為 簡化的版本，能夠捕捉到其幾何和拓撲特徵。Skeleton Matching 通過比較兩個形 狀的骨架圖的拓撲來判斷它們是否相似。在[40]中，Feng 等人透過脊線來加強 特徵點的比對，以避免錯誤比對。Sha 等人[41]將脊數用作特徵點的補充訊息。 Octant[42]使用八個方向上最近的特徵點的脊數來改善特徵點比對。在 EFS 格式 [43]中，NIST 提出了一個標準化的擴展特徵集，包括骨架、點和毛孔。

大多數作者沒有明確考慮變形，而是透過比對特徵點誤差的小位移來處理 [44]，當特徵點位置在影像中位置被定義時，變形會影響這兩個二維坐標，因此 在 Bohné 和 Despiégel[44]的研究中提出了一種指紋局部骨架描述器(Local Skeleton Descriptor)的方法，該描述器在特定坐標系統中編碼區域內特徵點的位 置，在系統中僅通過使用脊數(Ridge count)使一個坐標對變形影響。兩點之間的 脊數定義為連接這兩點的線段所跨越的脊線數量。當連接兩點的線段接近於脊 線流(ridge flow)的正交時，任何變形都不太會影響脊數。

研究中先定義基脊(Base ridge)如圖 2.8 (a)所示，並將特徵點分為端點和正特 徵點如圖 2.8 (b)與負特徵點如圖 2.8 (c)所示，在描述器中每個特徵點都表示為 M=(x,y,type)，因此最後每個描述器呈現的特徵點骨架如圖 2.9 所示，正特徵點 用藍色星星表示，負特徵點用紅色十字架表示。

---

![圖片：figure-25-10.jpg](images/figure-25-10.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體理解：**

這張圖片（圖2.9）是研究中特徵點骨架的可視化表示。研究人員將圖像中的特徵點分為三類：基脊、端點和正/負特徵點，並用特定的符號來標記它們，以便於後續的描述子生成。

**具體分析：**

*   **圖片內容:** 圖片展示了一條彎曲的線條（可能是指圖像中的某個結構），線條上標記了多個特徵點。
*   **正特徵點 (Positive Features):**  用藍色星星 (*) 表示，在圖中清晰可見。這些特徵點代表著線條上的特定位置，可能對應於線條的峰值或重要的轉折點。
*   **負特徵點 (Negative Features):** 雖然圖片本身沒有直接標記紅色十字架，但根據上下文文字描述，負特徵點用紅色十字架表示。這意味著在其他圖（如圖2.8(c)）中可以找到負特徵點的具體表現形式。
*   **基脊 (Base Ridge):**  圖片前的上下文提到“研究中先定義基脊”，並參考了圖 2.8 (a)。基脊是整個特徵提取流程的基礎，它可能代表著圖像中的主要結構或骨架線條。
*   **描述子表示:** 研究人員使用 M=(x, y, type) 來表示每個特徵點，其中 x 和 y 代表特徵點的座標，type 則代表該特徵點的類型（基脊、端點、正特徵點或負特徵點）。最終，這些特徵點骨架就由這種形式的描述子呈現。
*   **箭頭:** 圖中存在一個紅色箭頭，可能表示了特徵提取的方向或者線條的流向。

**總結：**

圖 2.9 展示的是經過特徵點分類後的圖像骨架，其中藍色星星代表正特徵點，而負特徵點則用紅色十字架標記（雖然圖片中未顯示）。這種表示方式是為了方便研究人員提取和描述圖像中的重要結構信息。整個流程始於定義基脊，然後將特徵點分為不同的類型，並使用特定的座標和類型信息來構建描述子。

希望這個分析對您有所幫助！

---

---

![圖片：figure-25-11.jpg](images/figure-25-11.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## Grafcet 流程圖文字描述：特徵點骨架描述器生成流程

這個 Grafcet 流程圖描述了基脊定義後，將特徵點分類並最終生成特徵點骨架描述器的過程。

**初始步驟 (Step 1 - 雙線方塊):**  系統處於待機狀態，等待基脊定義完成。此時，尚未進行任何特徵點的分類或處理。

**流程演進:**

從初始步驟出發，系統進入 Step 2。

**Step 2:** 定義基脊 (Base ridge)。此步驟表示完成了基脊的定義工作。

**Step 3:** 分類端點和正特徵點。此步驟將特徵點分為端點和正特徵點。

**Step 4:** 分類負特徵點。此步驟將特徵點分類為負特徵點。

**Step 5 (分支):**  在 Step 4 完成後，流程經過一條橫線，連接到兩個流程：一個是描述器生成，另一個是循環返回初始步驟。根據 Grafcet 規則總綱第 4 條的判斷，此處為**選擇性分支**。因為橫線之後的每個流程都有其各自獨立的條件（未在圖中顯示，但可以推測需要滿足特定分類完成條件才能進入後續流程）。

* **分支一：描述器生成 (Step 6):**  如果所有特徵點都已成功分類，則系統進入 Step 6。此步驟表示每個特徵點被表示為 M=(x,y,type)，即包含 x 座標、y 座標和類型資訊。
* **分支二：返回初始步驟 (未編號):** 如果特徵點分類尚未完成，流程將循環返回初始步驟（Step 1），等待基脊定義或特徵點的更新。

**Step 7:** 生成特徵點骨架描述器。此步驟表示最終生成了包含正特徵點（藍色星星）和負特徵點（紅色十字架）的特徵點骨架描述器。

**循環:**

完成 Step 7 後，流程結束。在實際應用中，通常會將 Step 7 的輸出作為下一個任務的輸入，或者根據需要返回初始步驟重新開始整個過程，例如基脊發生變化時。

**總結:**

這個 Grafcet 流程圖描述了一個特徵點分類和骨架生成的工作循環。系統首先定義基脊，然後分別對特徵點進行端點、正特徵點和負特徵點的分類。完成分類後，系統會將每個特徵點表示為 M=(x,y,type)，並最終生成包含所有特徵點資訊的骨架描述器。如果特徵點分類不完整，流程可以循環返回初始步驟重新開始。

---

---

![圖片：figure-25-12.jpg](images/figure-25-12.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文的內容：

**總體理解：**

這張圖片（圖2.8 (a)）展示的是一個區域性座標系下的骨架對應關係示意圖，很可能來自於圖像處理或計算機視覺領域，具體應用可能是指紋識別、紋理分析等。圖片的重點在於標示了負特徵點和基脊（Base ridge）。

**詳細解讀：**

1.  **上下文信息：**
    *   前文提到“負特徵點用紅色十字架表示”。
    *   後文提到“骨架對應”，並有(a) (c)的標籤，暗示這張圖是系列圖的一部分。
2.  **圖片內容分析：**
    *   **區域座標系：** 圖片左側的區域內，建立了一個以原點為中心的座標系，橫軸範圍從-4到4，縱軸範圍從-8到9（雖然圖片只顯示了部分）。
    *   **骨架線：**  圖中灰色的條紋代表骨架線。這些線可能表示圖像中的主要結構或邊緣。
    *   **基脊 (Base ridge)：** 圖片底部用紅色矩形標註了“基脊”，英文為"Base ridge"。這很可能是指骨架線的起始點或重要的參考線段。
    *   **負特徵點：**  在座標 (-2.5, 3) 的位置，有一個紅色的十字架標記，表示一個負特徵點。根據前文信息，紅色十字架代表負特徵點。
    *   **數字標籤：** 在基脊的下方，有從-4到4的數字標籤，可能表示骨架線在橫軸上的位置或索引。

3.  **圖片目的推測：**
    *   這張圖很可能是為了說明如何提取圖像中的骨架線，並在骨架線上標記重要的特徵點（例如負特徵點）。
    *   基脊可能是一個用於定位或校準的參考元素。
    *   座標系的存在表明，這些特徵點的位置是可量化的，可以用數值表示。

**總結：**

圖2.8 (a) 呈現了一個區域性骨架線示意圖，其中標註了基脊和一個負特徵點的座標位置。這張圖很可能是圖像處理算法中的一個中間步驟或結果展示，用於說明如何提取圖像特徵並進行定位。

---

---

![圖片：figure-25-13.jpg](images/figure-25-13.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容。

**總體理解：**

這張圖片是關於指紋特徵點分析的一部分，具體展示了在指紋骨架（Base-ridge）上如何定義和標示負特徵點。圖片與上下文文字共同說明了區域座標系統、正特徵點以及負特徵點的概念。

**詳細解讀：**

1. **圖 2.8 的整體框架:**  這張圖是圖 2.8 的一部分，包含三個子圖 (a), (b) 和 (c)。上下文文字明確指出，(a) 是區域座標系統（Base-ridge），(b) 是正特徵點，而 (c) 就是我們關注的負特徵點。

2. **(a) 區域座標系統 (Base-ridge):**
   *  圖中展示了指紋線條，並用紅色標示出一個參考點，其座標為 (-2, 5, 3)。這個座標系統是建立在指紋骨架上的，用於定位和描述特徵點。
   *  “基脊 (Base ridge)”的標籤說明了這些線條代表的是指紋的主要骨架結構。

3. **(c) 負特徵點:**
   *  圖中用紅色曲線表示指紋線條中的一個分叉或終止點，並用藍色星星標示。根據上下文文字“用藍色星星表示, 負 特 徵 點”，可以確定這些藍色星星代表的是負特徵點。
   *  負特徵點通常指的是指紋線條突然斷裂、分叉或者出現異常形態的點，它們是識別指紋的重要依據之一。

4. **箭頭指示:** 圖中紅色箭頭表示指紋線條的方向或流向，幫助理解特徵點在指紋骨架上的位置和變化。

**上下文關聯：**

*   “7 aE 一 ee (a) 28 nkosi A” 和 “一 人 (a) 28 nkosi A st(Boncidsey 9 -8 7 Oar ON 圖 2.9 骨架 對 應 的”  這些文字片段可能代表的是實驗數據或標記，與具體的指紋樣本相關。
*   圖 2.9 “骨架對應的” 表明了後續內容會展示骨架結構的應用或者更進一步的分析。

**總結：**

這張圖片清晰地展示了負特徵點在指紋骨架上的定義和標示方法，並與區域座標系統和正特徵點的概念聯繫起來，是理解指紋識別算法中特徵提取步驟的重要組成部分。藍色星星的標記方式是關鍵信息，幫助讀者快速識別圖中的負特徵點。

---

---

![圖片：figure-25-14.jpg](images/figure-25-14.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容。

**總體理解：**

這張圖片是關於圖像特徵點的說明圖，特別是負特徵點的視覺呈現。它與區域座標系統（Base-ridge）和正特徵點相關聯，屬於圖像處理或計算機視覺領域的概念圖解。

**詳細分析：**

1. **圖片標題及上下文關聯:**
   * 圖片標題為“圖 2.8 (c)負特徵點”。結合前文文字“負特徵點 7 aE 一 ee”和後文文字“圖 2.8 (a)區域座標系統(Base-ridge) (b)正特徵點 (c)負特徵點”，可以確定這張圖片展示的是圖像中的負特徵點。

2. **圖片內容解讀:**
   * **左側部分：** 展示了基於區域座標系統（Base-ridge）的圖像區域，可以看到一系列彎曲的線條，這些線條代表著圖像的梯度方向或等高線。線條的密集程度和方向反映了圖像局部區域的紋理變化。
   * **紅色箭頭及點位標記：**  圖片中用紅色的箭頭標示出一個閉合迴路，這個迴路圍繞著幾個特定的點。這些點分別標記為 (-9, -1), (-6, -2), (-3, 2), (2, 1), (4, -2), (5, 5, 4) 和 (3, -4)。
   * **右側部分：**  是一個座標系，橫軸範圍從-9到8，縱軸範圍從-4到6。這個座標系很可能用於表示左側圖像區域中這些特徵點的具體位置。

3. **負特徵點的意義:**
    * 在圖像處理中，特徵點通常是圖像中具有顯著變化或獨特性質的位置。正特徵點和負特徵點代表了不同類型的局部紋理結構。
    * 根據圖片中的箭頭方向，可以推測這些點所圍繞的區域是一個“凹陷”或“旋渦”狀的結構。這種結構在梯度變化上具有一定的特殊性，因此被定義為負特徵點。

4. **上下文文字補充:**
   * 前文提到 "7 aE 一 ee"，這可能代表著某種算法或參數設定，用於提取這些負特徵點。
   * 後文的圖 2.8 (a)區域座標系統(Base-ridge) 表明了圖像分析所使用的坐標系，而圖 2.8 (b)正特徵點則提供了與負特徵點相對應的正特徵點的視覺呈現，可以通過比較兩者來更深入地理解不同類型特徵點的特性。

**總結：**

這張圖片展示了在基於區域座標系統下提取的圖像負特徵點及其位置信息。紅色箭頭標示的閉合迴路圍繞著一系列具有特定坐標的點，這些點代表了圖像中局部紋理結構為“凹陷”或“旋渦”狀的區域，從而定義為負特徵點。圖片與前後文文字共同構成了對圖像特徵點概念的完整說明。

---

圖 2.8 (a)區域座標系統(Base-ridge) (b)正特徵點 (c)負特徵點

---

![圖片：figure-25-15.jpg](images/figure-25-15.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容。

**總體理解：**

這張圖（圖2.9）展示了指紋骨架對應的區域骨架描述器，是骨架比對演算法中的一個關鍵步驟。它將指紋特徵點進行註冊，並利用局部描述器來建立座標系統，以便於比較不同指紋之間的相似性。

**圖片細節分析：**

*   **左側圖形：**
    *   呈現的是指紋的骨架結構，由密集的曲線組成。這些曲線代表指紋紋線的走向。
    *   紅色圓圈標記了指紋上的特徵點，並用座標 (x, y) 進行標註。例如，(-5, 5), (-3, 2), (2, 1) 等等。這些座標是基於區域座標系統（Base-ridge）的定位結果。
    *   圖中箭頭指示了紋線流向，可以觀察到指紋紋線具有一定的方向性。

*   **右側圖形：**
    *   是一個散點圖，橫軸和縱軸都標有數值範圍（-9 到 8）。
    *   藍色星號 (*) 代表著經過轉換後的特徵點座標。
    *   紅色加號 (+) 代表著原始的特徵點座標。
    *   藍色的虛線表示通過概率方法尋找最佳重疊特徵點集所得到的變換曲線，用以描述指紋比對過程中的變形。

**結合上下文的解釋：**

1.  **骨架比對演算法的三個階段：** 圖片是該演算法的第一階段的結果，即指紋特徵點的註冊。
2.  **區域座標系統（Base-ridge）：** 左側圖形的座標 (x, y) 是基於這個系統建立的，用於定位指紋上的特徵點。
3.  **局部描述器：** 沿紋線流向約有 200 像素長度的局部描述器被用來提取指紋特徵，並進行比對。
4.  **變換參數：** 比對過程中需要考慮線性延伸 (s)、沿紋線流向平移 (tx) 和垂直紋線流向平移 (ty) 三個變換參數。
5.  **概率方法和最佳重疊：** 由於比對特徵點對未知，演算法採用概率方法尋找最佳重疊最多的特徵點集，並通過變換曲線（右側圖形的藍色虛線）來描述指紋的變形。

**總結：**

這張圖片展示了骨架比對演算法中利用區域座標系統定位指紋特徵點，並通過局部描述器和概率方法尋找最佳重疊特徵點集，建立指紋骨架對應關係的過程。右側圖形的散點圖和變換曲線反映了比對過程中指紋的變形情況。

希望這個分析能夠幫助您理解這張圖片及其前後文內容！

---

圖 2.9 骨架對應的區域骨架描述器

骨架比對演算法由三個階段組成，第一階段透過演算法將指紋特徵點的影 像進行註冊，局部描述器沿紋線流向約有 200 像素長，變形可近似為線性延伸， 變換參數為：s(線性延伸)、tx(沿紋線流向平移)和 ty(垂直紋線流向平移)。最佳 轉換(Transformation)的難點在於未知的比對特徵點對(Minutia pairs)，因此採用概 率方法，尋找最佳重疊最多特徵點集的轉換。

接著從兩個指紋中選擇 N 對對應的點，使用霍夫轉換來找出最佳參數 (s, tx, ty)。每對比對的特徵點在離散參數空間中對(s, tx, ty) 進行計算，如公式(2.6)。

𝑉𝑜𝑡𝑒(log(𝑠),𝑡𝑥,𝑡𝑦)

∑ 𝑖 𝑀𝑠𝑟𝑐 𝑘 ∈ 𝑚𝑖𝑛𝑢𝑡𝑖𝑎𝑒 𝑓𝑟𝑜𝑚 𝑠𝑒𝑎𝑟𝑐ℎ 𝑝𝑟𝑖𝑛𝑡 𝑀𝑠𝑟𝑐 𝑗 𝑀𝑅𝑒𝑓 𝑙 𝑀𝑟𝑒𝑓 ∈ 𝑚𝑖𝑛𝑢𝑡𝑖𝑎𝑒 𝑓𝑟𝑜𝑚 𝑟𝑒𝑓𝑒𝑟𝑒𝑛𝑐𝑒 𝑝𝑟𝑖𝑛𝑡 𝑗 𝑖 = 𝑡𝑦𝑝𝑒𝑅𝑒𝑓 𝑤𝑖𝑡ℎ 𝑡𝑦𝑝𝑒𝑆𝑟𝑐 𝑘 = 𝑡𝑦𝑝𝑒𝑟𝑒𝑓 𝑙 𝑎𝑛𝑑 𝑡𝑦𝑝𝑒𝑆𝑟𝑐

𝑃(log(𝑠),𝑡𝑥,𝑡𝑦|𝑀𝑠𝑟𝑐

兩對特徵點：

𝑖 (𝑀𝑠𝑟𝑐 𝑗 )、(𝑀𝑆𝑟𝑐 𝑘 ,𝑀𝑅𝑒𝑓 𝑙 ,𝑀𝑟𝑒𝑓

s、tx 分別表示：

𝑥𝑆𝑟𝑐 𝑗 − 𝑡𝑥 𝑖 = 𝑠 × 𝑥𝑅𝑒𝑓 { 𝑘 = 𝑠 × 𝑥𝑅𝑒𝑓 𝑙 − 𝑡𝑥 𝑥𝑆𝑟𝑐 ⟹ { 𝑠 = 𝑖 − 𝑥𝑆𝑟𝑐 𝑘 𝑥𝑆𝑟𝑐 𝑗 − 𝑥𝑅𝑒𝑓 𝑙 𝑥𝑅𝑒𝑓 𝑖 𝑡𝑥 = 𝑥𝑆𝑟𝑐 𝑗 − 𝑠 × 𝑥𝑅𝑒𝑓

若計算後，每對兩個特徵點類型相同時，則比對成功成功機率較高為公式 (2.7)

𝑖 𝑃(𝑚𝑎𝑡𝑐ℎ(𝑀𝑆𝑟𝑐 ,𝑀𝑅𝑒𝑓 ))

∝ {𝑒 − 𝑗 𝑖 −𝑦𝑟𝑒𝑓 (𝑦𝑠𝑟𝑐 2 2𝜎𝑦 )2 − 𝑗 𝑖 −𝑥𝑅𝑒𝑓 (𝑥𝑆𝑟𝑐 2 2𝜎𝑥 )2 , 𝑗 𝑖 = 𝑡𝑦𝑝𝑒𝑅𝑒𝑓 𝑖𝑓 𝑡𝑦𝑝𝑒𝑆𝑟𝑐 (2.7) 0 𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒

第二階段使用動態規劃(Dynamic programming)在搜尋指紋和參考指紋間找 到一對特徵，其成本矩陣公式如公式(2.8)。在尋找特徵點集 A 時，使其在比對 成本總和最小的情況下沒有特徵點被重複使用的情況，這個最小值用來計算相 似度分數如公式(2.9)。

成本矩陣：𝐶𝑜𝑠𝑡𝑖𝑗 = 1 − 𝑃(𝑚𝑎𝑡𝑐ℎ(𝑀𝑆𝑟𝑐 𝑖 𝑗 ,𝑀𝑅𝑒𝑓 )) (2.8)

相似度分數：𝑆𝑐𝑜𝑟𝑒 = −𝑚𝑖𝑛 (∑ (𝑖,𝑗) ∈ 𝐴 𝐶𝑜𝑠𝑡𝑖𝑗 ) 𝐴 (2.9)

下限：(𝑖,𝑗) ∈ 𝐴 ⟹ ¬∃(𝑖,𝑘) ∈ 𝐴 𝑤𝑖𝑡ℎ 𝑘 ≠ 𝑗.

第三階段為計算兩指紋的全域性相似性得分，因此合併了從許多局部描述 器中計算出的分數。使用指紋中每個特徵點計算一個描述器，以產生選擇清單。 接著透過描述器中的局部特徵點密度來計算每個描述器的機率，選擇機率最高 的描述器(d)，將其從選擇清單中移除，若機率 p(d)低於閥值或選擇的描述器數 量超過Ｎ，則結束。

計算兩個描述器之間的相似性分數完，最後才是輸出分數的平均值。其每一 描述器(d’)計算公式如(2.10)：

𝑝𝑘+1(𝑑′) = 𝑝𝑘(𝑑′) × (1 − 𝑒− 𝑑𝑠𝑡(𝑑,𝑑′)2 2𝜎2 ) (2.10)

在實驗最後結果說明，骨架演算法的錯誤接受率大約是特徵點比對器的兩 倍。 這種準確性的差異可能主要是因為骨架演算法不使用定向資訊，它只執行 許多區域性比對，不像特徵點比對器那樣使用全域一致性的特徵。

## 2.2.4 Minutia 演算法比對

特徵點比對是通過比較指紋的細節特徵，也就是指紋留下的細小痕跡 (minutia)，來識別兩個指紋是否相同。指紋圖像由脊紋和谷紋構成，形成獨特的 結構，從不同指尖脊紋產生的影像中擷取結構，有兩種類型的指紋，分為平面或 傾斜。平面指紋包括指尖和第一個指節之間的中心區域影像，而傾斜影像中，脊 紋存在於手指的兩側，因此被稱為滾動影像[45]。

然而，Singh 等人[46]提出了一種新的指紋特徵檢測演算法，該演算法改善 由指紋影象中存在的掃瞄指紋機造成的扭曲、旋轉、位移或雜訊產生的不良特徵

點問題。 為了解決這個問題，他們設計了一種有效的特徵擷取策略，可以擷取 真正的特徵，只過濾和保留可以進一步用於指紋比對的關鍵特徵點。

Yin、Pan 等人[47]也提出採集過程中手指方向、位置、角度、壓力的變化， 指紋特徵點產生了旋轉、平移、變形的問題，為了解決此問題，需要先將特徵點 進行對齊，才可依照特徵點的對應關係來比對其相似度。因此此研究分為三個步 驟，首先擷取指紋特徵點，並將特徵點表示為四維特徵(𝑝 = {𝑥,𝑦,𝜃,𝑡})，x 、 y 表示特徵點位置，𝜃表示特徵點方向(𝜃 ∈ [0,2𝜋])，t 表示特徵點型別(端點或分岔 點)。特徵點𝑝𝑎與特徵點𝑝𝑏的脊線數(Ridge lines)表示為𝛾(𝑝𝑎,𝑝𝑏)，而所有脊線數 矩陣則表示為Γ[𝑐,𝑑] = 𝛾(𝑝𝑐,𝑝𝑑)。

第二步驟特徵點對齊後，透過局部比對方法來計算給定的指紋特徵和資料 庫特徵之間的局部比對關係。 使用匹配對(Matching pair)結構的區域性特徵相鄰 描述器(Minutia neighborhood descriptor)，建立了中心點及其周圍點之間的空間和 方向關係，這種結構只取決於兩個特徵點和脊線資訊之間的相對位置關係，因此 不會將指紋平移或旋轉角度內入計算。兩個排序的特徵點及其相應的脊線矩陣， 分別為測試特徵集(Template minutia) 𝑃＝{𝑝1,...,𝑝𝑛}及其脊線矩陣𝛤𝑃，以及樣本 特徵集(Sample minutia)𝑄 = {𝑞1,⋯,𝑞𝑚}及其脊線矩陣𝛤𝑄。

比對的特徵點變數說明如圖 2.0 所示：

---

![圖片：figure-28-16.jpg](images/figure-28-16.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您詳細解讀這張圖片及其前後文的內容：

**總體概述:**

這張圖（圖2.0）展示了指紋比對中「匹配對(Matching pairs)」的概念以及其相關參數。上下文文字說明，在特徵點對齊後，會使用局部比對方法計算測試指紋和樣本指紋之間的相似度。而「匹配對」是這種局部比對的核心結構，它描述了兩個指紋中的一個特徵點及其周圍區域的空間和方向關係。

**圖片細節解讀:**

圖中呈現了兩個類似的三角形結構，分別代表測試指紋（Template minutia）和樣本指紋（Sample minutia）中的一對匹配特徵點：

*   **`ps` 和 `qs`**: 分別代表測試指紋和樣本指紋中的中心特徵點。
*   **`pr` 和 `qr`**: 分別代表測試指紋和樣本指紋中與中心特徵點相鄰的另一個特徵點。
*   **`d_p` 和 `d_q`**:  分別表示測試指紋和樣本指紋中，中心特徵點到其相鄰特徵點之間的距離。
*   **`α_p` 和 `α_q`**: 分別表示測試指紋和樣本指紋中，中心特徵點與相鄰特徵點連線的方向角（通常是脊線方向）。
*   **`β_p` 和 `β_q`**: 分別表示測試指紋和樣本指紋中，相鄰特徵點的脊線方向角。
*   **`θ_p` 和 `θ_q`**:  分別表示測試指紋和樣本指紋中，中心特徵點的角度。

**重要概念:**

*   **區域性特徵相鄰描述器 (Minutia neighborhood descriptor)**：這張圖所展示的結構就是這種描述器的視覺表現。它關注的是一個特徵點及其周圍脊線資訊的相對位置關係。
*   **不考慮平移和旋轉**: 上下文強調，這個匹配對的結構只依賴於兩個特徵點之間的相對位置關係，因此不受指紋平移或旋轉角度的影響。這使得比對過程更加魯棒。

**總結:**

圖2.0 旨在說明在指紋局部比對中，如何使用「匹配對」來捕捉兩個指紋特徵點及其周圍脊線資訊的空間和方向關係。通過比較這些參數（距離、角度等），可以評估兩個特徵點之間的相似度，進而實現指紋比對。

希望這個解釋能夠幫助您理解這張圖片及其上下文內容！

---

圖 2.10 匹配對(Matching pairs)與其相關參數

中心點：𝑝𝑠、𝑞𝑠

中心點的周圍點：𝑝𝑟、𝑞𝑟

因此可以分別組成測試特徵集對(Template minutia pair){𝑝𝑠,𝑝𝑟}、樣本特徵集 對(Sample minutia pair){𝑞𝑠,𝑞𝑟}

兩對之間距離：𝑑𝑝、𝑑𝑞

中心點的定向角度：𝛼𝑝、𝛼𝑞

周圍點的定向角度：𝛽𝑝、𝛽𝑞

中心點和周圍點的連線與正 X 軸方向之間的角度：

𝜃𝑝 = 𝑎𝑟𝑐𝑡𝑎𝑛 𝑦𝑝𝑠−𝑦𝑝𝑟 𝑥𝑝𝑠−𝑥𝑝𝑟 、𝜃𝑞 = 𝑎𝑟𝑐𝑡𝑎𝑛 𝑦𝑞𝑠−𝑦𝑞𝑟 𝑥𝑞𝑠−𝑥𝑞𝑟

研究中考慮量化誤差，包含手指硬體感測器變形、感測器本身感應問題，為 了消除不良特徵點，因此只將符合公式(2.11)條件的特徵點納入至集合中，

特徵點選取條件：

{ |𝛾𝑝 − 𝛾𝑞| < 𝑇𝛾 |𝑑𝑝 − 𝑑𝑞| < 𝑇𝑑 |(𝛽𝑝 − 𝛼𝑝) − (𝛽𝑞 − 𝛼𝑞)| < 𝑇𝛼𝛽 |(𝛽𝑝 − 𝜃𝑝) − (𝛽𝑞 − 𝜃𝑞)| < 𝑇𝛽𝜃 (2.11)

符合條件的特徵點集：𝐴 = {𝑝𝑠,𝑞𝑠,𝑝𝑟,𝑞𝑟}

其結果範例如圖 2.1。最後符合局部比對結果Ａ特徵點集({𝐴1,𝐴2,...,𝐴𝑘})結

果輸出為矩陣。

---

![圖片：figure-29-17.jpg](images/figure-29-17.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來分析這張圖片及其前後文，並提供最精準的解釋：

**總體理解：**

這張圖（圖2.1）展示的是局部比對結果，具體來說是符合條件的特徵點匹配對。它描述了在兩個圖像中，經過某種算法篩選後，找到的一組相對應的特徵點集。

**詳細解釋：**

1. **上下文關聯：**
   *  “其結果範例如圖 2.1” 表明這張圖片是局部比對算法輸出的一個例子。
   * “最後符合局部比對結果Ａ特徵點集({𝐴1,𝐴2,...,𝐴𝑘})結果輸出為矩陣。”說明，最終的匹配結果會被表示成一個矩陣，這個矩陣包含了所有找到的匹配特徵點的信息。
   *  “圖 2.11 𝑝𝑠、𝑞𝑠為中心的符合條件匹配對結果” 表明這張圖片是為了展示在兩個圖像中，以 `ps` 和 `qs` 為中心，經過篩選後符合特定條件的特徵點匹配。

2. **圖片內容分析：**
   *  圖中有兩個圓圈，可以理解為來自兩幅不同的圖像。
   *  每個圓圈內都有許多小的白色圓圈，這些代表著圖像中的特徵點。
   *  紅色標記的 `ps` 和 `qs` 分別是這兩個圓圈的中心點，它們可能是關鍵特徵點或參考點。
   *  用紅色的虛線框住了每個圓圈內的一部分區域，表示符合條件的特徵點範圍。
   *  在每個圓圈中，只有部分白色圓圈被包含在紅色虛線框內，這些被包含的特徵點就是“符合局部比對結果Ａ特徵點集”。

3. **推論：**
    * 算法可能先找到兩個圖像中的所有特徵點，然後以 `ps` 和 `qs` 為中心進行局部搜索。
    *  只有在 `ps` 周圍的特定區域內（紅色虛線框）的特徵點，才被認為與 `qs` 周圍的特定區域內的特徵點匹配。
    *  這些符合條件的特徵點組成了“Ａ特徵點集”，並最終以矩陣的形式輸出。

**總結：**

這張圖展示了局部比對算法在兩個圖像中找到的一組相對應的特徵點，這些特徵點是基於特定中心點（`ps` 和 `qs`）和局部範圍篩選出來的。 最終匹配結果會被表示成一個矩陣。  可以理解為一種基於鄰域關係的特徵點匹配方法。

---

圖 2.11 𝑝𝑠、𝑞𝑠為中心的符合條件匹配對結果

第三步驟建立指紋拓撲關係(Topological relationship)和建立特徵點之間相關 性的方法。 然而，拓撲關係計算指紋的全域性相似性，以定量評估兩個特徵點 之間的相似性，如公式(2.12)。

相似度分數：

𝑐𝑝為測試特徵點中心鄰近的周邊點數量

𝑐𝑞為樣本特徵點中心鄰近的周邊點數量

𝑐(𝑝𝑖,𝑞𝑗)為特徵點𝑝𝑖與特徵點𝑞𝑗 為中心點的全域性匹配對數量

𝑣(𝑝𝑠,𝑞𝑠,𝑝𝑟,𝑞𝑟)

= 𝑚𝑖𝑛( 𝑐𝑝 𝑐(𝑝,𝑞) ,1) ∙ 𝑚𝑖𝑛( 𝑐𝑞 𝑐(𝑝,𝑞) ,1) ∙ ∆𝛾𝑝𝑞 ∙ 𝛥𝑡𝑝𝑞 ∆𝛾𝑝𝑞 = { 1 , 0.7 , 𝑖𝑓 𝛾𝑝 = 𝛾𝑞 𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒 𝛥𝑡𝑝𝑞 = { 1 , 0.7 , 𝑖𝑓 𝑡𝑟𝑝 = 𝑡𝑟𝑞 𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒 (2.12)

在全域相似性計算中，設計了三個子指標，從不同角度評估兩個特徵點的相 似性，最後計算指紋的整體相似性，其計算步驟如下：

第一步驟依據匹配對數量的分數：正負全域性匹配對的數量差異很大，使匹 配對的數量成為評估指紋相似性的重要指標。使用具有特定參數的 S 型函式 (Sigmoid function)來計算匹配對數量的分數，參考公式(2.13)，參數是根據來自正 負樣本的大量比對資料。

𝑆𝑛𝑢𝑚 = 𝑍(𝑛𝑝𝑎𝑖𝑟𝑠,𝜇𝑛 ,𝜏𝑛) (2.13)

𝑛𝑝𝑎𝑖𝑟𝑠表示全域性匹配對的數量

sigmoid 函式表示為Ｚ，並且定義參數𝜇𝑛、𝜏𝑛

因此 sigmoid 表示如下(2.14)：

𝑍(𝑛,𝜇,𝜏) = 1 1 + 𝑒−( 𝑣−𝜇 𝜏 ) (2.14)

第二步驟依據局部相似度的分數：局部相似性分數(LSS)方法按降序對所有 全域性匹配對的相似性分數進行排序，如公式(2.16)。

𝑂𝑙𝑠𝑠 = {(𝑝𝑠𝑐,𝑞𝑠𝑐,𝑝𝑟𝑐,𝑞𝑟𝑐)}, (2.15) 𝑐 = 1,...,𝑛𝑝,1 ≤ 𝑝𝑠𝑐 ≠ 𝑝𝑟𝑐 < 𝑚,1 ≤ 𝑞𝑠𝑐 ≠ 𝑞𝑟𝑐 ≤ 𝑛

而𝑛𝑝元素的平均分數是指紋的區域性相似性得分𝑆𝑙𝑠𝑠，如公式(2.16)。

𝑆𝑙𝑠𝑠 = 𝑍 ( ∑ (𝑝𝑠,𝑞𝑠,𝑝𝑟,𝑞𝑟)∈𝑂𝑘𝑠 𝑉[𝑝𝑠,𝑞𝑠,𝑝𝑟,𝑞𝑟] 𝑛𝑝 ,𝜇𝑙,𝜏𝑙) (2.16)

第三步驟最大叢集分數(Cluster Score)：在正指紋比對中，連線全域性匹配對 的樣本特徵點對和測試特徵點對構成覆蓋指紋整個重疊區域的最大叢集，為了 識別指紋中的叢集，隨意從任何特徵點開始，並使用深度第一搜尋(Depth-First Search)演算法來遍歷所有全域性匹配對。未遍歷的全域性匹配對不屬於叢集，可 以排除。

構成最大叢集的全域性匹配對的相似性分數集表示為：

𝑂𝑐𝑙𝑢𝑠𝑡𝑒𝑟 = {(𝑝𝑠,𝑞𝑠,𝑝𝑟,𝑞𝑟)},1 ≤ 𝑝𝑠𝑐 ≠ 𝑝𝑟𝑐 < 𝑚,1 ≤ 𝑞𝑠𝑐 ≠ 𝑞𝑟𝑐 ≤ 𝑛

計算重疊區域內指紋比對性能的分數是最大叢集的分數(2.17)。

𝑆𝑐𝑙𝑢𝑠𝑡𝑒𝑟＝ 𝑚𝑖𝑛(𝑝𝑐𝑜𝑣,𝑞𝑐𝑜𝑣) 𝑚𝑖𝑛(𝑝𝑛𝑢𝑚,𝑞𝑛𝑢𝑚) × 𝑍 ( ∑ (𝑝𝑠,𝑞𝑠,𝑝𝑟,𝑞𝑟)∈𝑂𝑐𝑙𝑢𝑠𝑡𝑒𝑟 𝑛𝑝𝑎𝑖𝑟𝑠 Γ[𝑝𝑠,𝑞𝑠,𝑝𝑟,𝑞𝑟] ,𝜇𝑐,𝜏𝑐) (2.17)

最後的最終相似值：最後，從全域性比對關係中提取各種參數，以計算指紋 的相似性分數，參考公式(2.18)。

𝑆＝𝑆𝑙𝑠𝑠 × 𝑆𝑐𝑙𝑢𝑠𝑡𝑒𝑟 × 𝑆𝑛𝑢𝑚 (2.18)

## 2.2.5 FLANN 演算法比對

FLANN (Fast Library for Approximate Nearest Neighbors) 是一種快速近似鄰 近搜尋演算法，設計用於大規模高維數據集的快速比對[48]。它在機器學習和計 算機視覺中廣泛應用，特別是在圖像檢索和特徵比對領域。

如 Vijayan[49]。研究顯示將快速近似鄰近搜索演算法(FLANN)應用於生物 辨識中的特徵比對，結合 SIFT 技術，提升了人臉特徵檢測的準確性與效率。 FLANN 在處理高維數據時展現出卓越的比對能力，透過多棵隨機化 KD 樹的算 法，顯著減少了錯誤比對，特別是在特徵點方向的比對上，FLANN 能有效處理 不同頭部姿勢所造成的特徵點偏移，提升比對準確率。

又如Ｗang 與 Li[50]研究中提供一個高效的相似圖像檢索系統，針對從不同 角度拍攝但場景或物體相同的相似影像，基於內容的影像檢索方法摘取不同影 像的像素特徵作為計算影像之間相似性的線索。實驗中使用了 INRIA Holidays 數據集與 ZuBuD 數據集，透過比較圖片顏色的特徵來計算相似性。實驗過程中， 丟棄了查詢影像中相似度小於閾值 0.24 的影像。這些研究展示了在處理高維圖 像特徵數據時的高效性與準確性，適用於多樣化的圖像檢索場景。

Gowandy、Halim 與 Santoso 也在研究中[51]提出了一種基於指紋識別與射 頻識別(RFID)的電子安全投票系統，旨在提高投票系統的安全性與效率。在指紋 辨識中，分析了兩種比對算法：暴力比對(Brute force matcher)和快速近似最近鄰 庫(FLANN matcher)。FLANN 比對器中使用的算法包括分層 k-means 樹算法和 隨機化 k-d 樹算法。分層 k-means 樹算法使用優先佇列，根據每個 k-means 區域 與查詢之間的距離，按順序擴展搜索範圍。同時，隨機化 k-d 樹算法通過選擇分 割維度構建隨機樹，在樹的每一層將數據分為兩部分，並選擇數據方差最大的維 度進行分割，與暴力比對相比，FLANN 比對在處理大型數據集時運行速度更快 。 FLANN 比對在處理大規模數據集時的效率與準確性均優於暴力比對。此外，該 22

系統通過 RFID 標籤與指紋圖像的聯合驗證，顯著縮短了指紋比對的處理時間， 增強了整體系統的實用性。

其比對流程可以分為四個主要階段[52] [53]：首先是數據預處理階段，系統 會收集待比對的指紋特徵點數據，並將這些圖片中擷取出的特徵點轉換為高維 度特徵向量。

第二階段是索引建立階段，系統會構建索引結構，通常多維度的特徵點使用 多個 KD 樹的集合來進行。KD 樹(K-dimension tree)存儲 K 維空間中，主要進行 快速檢索的樹形數據結構，KD 樹是一種二元樹，表示對 K 維空間的劃分，使用 垂直於坐標軸的超平面將 K 維空間切分，形成一個 K 維矩形區域，每個節點對 應一個 K 維矩形區域，如圖 2.12 輸入(a)黄色特徵點為樹根(root)，用分割維度線 以上的為左子樹，線以下的為右子樹，接著不斷劃分，即如輸出(b)圖示分為 K

---

![圖片：figure-33-18.jpg](images/figure-33-18.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我將根據提供的上下文文字和圖片內容，為您提供一份詳細的 KD 樹示意圖解說：

**總覽：KD 樹是為了快速檢索多維度特徵點而設計的一種樹形數據結構。** 這張圖 2.12 正是展示了 KD 樹構建過程中的兩個階段，以及其核心概念。

**圖片 (a) – 初始化與第一次分割:**

*   **黃色特徵點：** 代表樹的根節點（root）。這個根節點是KD樹建立的起點。
*   **藍色特徵點：** 代表需要被索引的數據點，它們將會被組織到 KD 樹中。
*   **黑色直線：**  代表分割維度線。這條線垂直於一個坐標軸（具體哪個軸取決於當前維度），用來將 K 維空間劃分為兩個矩形區域。
*   **分割原理：** 圖示中的分割線是根據某個維度的值進行劃分，上方點集為左子樹，下方點集為右子樹。

**圖片 (b) – 遞歸分割:**

*   **綠色和紅色特徵點：** 代表 KD 樹的內部節點。
*   **白色特徵點：** 代表葉節點，也就是最終的數據點。
*   **樹形結構：**  KD 樹是一種二元樹，每個節點都有左子樹和右子樹。
*   **遞歸劃分：** KD 樹的構建過程是遞歸的。從根節點開始，根據某個維度將空間劃分為兩個區域，然後在每個區域內繼續分割，直到達到葉節點。
*   **K 個維度：**  圖中顯示了不斷地按照 K 個維度進行劃分，這意味著 KD 樹會輪流選擇不同的維度來分割數據。

**結合上下文的理解:**

*   **索引建立階段：** 這張圖展示的是 KD 樹構建過程中的核心步驟，也就是將多維度的特徵點組織成一個高效的索引結構。
*   **快速檢索：**  KD 樹通過不斷地分割空間，使得在搜索過程中可以快速排除掉一部分數據點，從而提高檢索效率。
*   **Hamming距離:** 後文提到使用 Hamming 距離來比較查詢向量與子節點的中心，這表示 KD 樹通常用於處理離散特徵或二元數據。

**總結：**

圖 2.12 清晰地展示了 KD 樹是如何通過遞歸分割空間的方式構建索引結構的。通過選擇不同的維度進行分割，KD 樹可以有效地組織多維度的特徵點，並為後續的鄰近距離搜尋提供基礎。  理解這張圖對於掌握 KD 樹的工作原理至關重要。

---

圖 2.12 KD 樹示意圖

第三階段為鄰近距離搜尋階段，搜索過程從樹的根節點開始，比較查詢向量 q 與每個子節點的中心。透過 Hamming 距離最小的子節點繼續搜索，重複此過 程直到達到葉節點，然後將葉節點中的所有點加入候選集。接下來進行 Hamming 距離計算，對於篩選出的每個候選項 p，計算其與查詢向量 q 的 Hamming 距離

公式如(2.19)，使用 XOR 操作可以通過位運算高效實現，提高計算速度。最後， 系統根據計算出的距離對候選項進行排序，選擇距離最小的 k 個作為最終的 k 近 鄰，從而完成整個近似最近鄰搜索過程。

p 表示資料集𝑃＝{𝑝1,...,𝑝𝑛}中的一個點(存儲在索引中的一個特徵向量)。 q 表示查詢點(想要找到其最近鄰的特徵向量)。

𝑛−1 𝑑ℎ𝑎𝑚𝑚𝑖𝑛𝑔(𝑝,𝑞) = ∑(𝑝𝑖 ⊕ 𝑞𝑖) 𝑖=0 (2.19)

第四階段在結果過濾階段，演算法參考 Lowe 在[54]中提出使用距離比率測 試來嘗試消除錯誤比對。計算考慮中的關鍵點的兩個最近比對之間的距離比率， 當該值低於某個閾值時，則認為這是一個好的比對。這個比率可以幫助區分模糊 比對(兩個最近鄰之間的距離比率接近 1)和區分良好的比對。最後，系統會輸出 比對結果，傳回最佳比對的列表，並提供相似度得分與距離。

FLANN 演算法犧牲一些精確度來換取更快的搜索速度，用戶可以根據需求 調整速度和準確性之間的平衡[55]。由於其演算法優點，多實驗將其比對方法列

入指紋比對研究中。

## 第三章、 可重構指紋特徵比對系統設計

本章主要基於 MIAT 實驗室提出的方法論執行可重構指紋特徵比對系統架 構設計，第一小節主要說明 MIAT 方法論如何將一個複雜的系統，透過問題所 需的理論、方法、模型、技術、工具以邏輯化的 IDEF0 階層式流程進行設計， 且針對每個功能獨立的模組進行 Grafcet 圖形流程建立離散事件模型，使問題導 向解答，第二小節將介紹將複雜的指紋特徵比對系統進行階層模組化設計，因應 現今消費性電子硬體產品週期縮短[56]，使複雜的系統為可重構的模組化設計， 解決日新月異不同的硬體設備所導致架構重構或修改，第三小節為每個設計的 模組進行離散事件建模與說明。

## 3.1 MIAT 方法論

MIAT 方法論基於 Top-Down 設計方式，階層式模組化的功能架構設計，配 合 Grafcet 圖形流程建立離散事件模型，再根據組成的法則實現軟體高階合成[57]， MIAT 架構示意如圖 3.1。綜整以上可知方法論在設計複雜系統有良好的成效， 複雜系統通常涉及多領域的知識，包括軟硬體介面設計與結合及團隊合作協調， 對於知識管理也有極大的幫助，透過模組的切割使個別工作降低重複性，使架構 可以為各種新產品提出快速開發流程的解決方案。

---

![圖片：figure-35-19.jpg](images/figure-35-19.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容進行分析，並以清晰的文字描述呈現。

**層級關係:** 此為系統的頂層圖表 (A0)。

**模組/子模組列表:**

*   **1. MIAT 系統設計方法論:**  這是整個圖表的中心模組。

**模組分析:**

*   **1. MIAT 系統設計方法論:**
    *   **輸入 (Input):**
        *   `系統需求`: (外部來源)
        *   `IDEF0 階層式模型`: (外部來源)
        *   `Grafcet 離散事件建模`: (外部來源)
    *   **輸出 (Output):**
        *   `系統統結`: (外部來源)
        *   `軟體高階合成`: (外部來源)
        *   `軟硬體介面設計與結合`: (外部來源)

**總結:**

圖 3.1 展示了 MIAT 系統設計方法論的頂層架構。該方法論接收來自外部的 `系統需求`、`IDEF0 階層式模型` 和 `Grafcet 離散事件建模` 作為輸入，並產生 `系統統結`、`軟體高階合成` 和 `軟硬體介面設計與結合` 等輸出。  此圖表強調了 MIAT 方法論的 Top-Down 設計方式和模組化架構，以及其在知識管理和快速開發流程方面的優勢。

---

圖 3.1 MIAT 系統設計方法論

本論文將指紋特徵比對系統用此方法執行方法論系統設計，以解決開發流 程可能面臨介面協調困難及研發控管不易問題，從而實現適應硬體規格變化的 需求，所需改變指紋特徵比對演算法，並設計出可重構指紋特徵比對系統架構。

## 3.1.1 IDEF0 階層式模組化設計

IDEF0 是一種功能建模的方法，大多應用於複雜系統的設計、分析。其階層

式模組化方法提供了一種有效的架構，用於系統功能的分解和組成。 首先逐層分解系統的主要功能，使每個子功能均能被詳細描述和分析。這種 Top- Down 的分解過程有助於理解系統的複雜性，並提供一種系統化的方法來管理各 個功能模組。系統的每個功能模組可以進一步分解為更小的子模組。這種逐層細 化的過程使每個功能模組的細節逐漸展現，從而達到全面描述系統功能的目的。 每個功能模組都通過 IDEF0 標準符號表示其輸入(Input)、輸出(Output)、控制 (Control)和機制(Mechanism)如圖 3.2。這些方塊定義了功能模組的邊界和內部結 構，並都會以代號標記，由最高層 A0 依序向下命名 A1、A2、A3…，有助於精 確描述模組的功能和相互關係。

---

![圖片：figure-36-20.jpg](images/figure-36-20.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容進行分析，並以繁體中文呈現結果。

**層級關係:** 此為系統的頂層圖表 (A0)。

**模組列表:**

*   **模組編號 1: IDEF0 Activity**

**模組詳細分析:**

*   **模組名稱：IDEF0 Activity**
    *   **輸入 (Input):**
        *   `Input`: (外部來源)
    *   **輸出 (Output):**
        *   `Output`: (流至 外部)
    *   **控制 (Control):**
        *   `Control`: (外部來源)
    *   **機制 (Mechanism):**
        *   `Mechanism`: (外部來源)

**總結:**

此圖表為頂層系統架構圖(A0)，展示了一個名為 "IDEF0 Activity" 的核心模組。該模組接收來自外部的 `Input`，並產生 `Output`。同時，它受到來自外部的 `Control` 控制，並透過 `Mechanism` 進行運作。  根據上下文描述，此圖表代表了 IDEF0 功能建模的基本組成元素及其資訊流動方式。

---

機 制 Mechanism

圖 3.2 IDEF0 功能模組

IDEF0 強調模組化設計，如圖 3.3 為例使用 IDEF0 表示 MIAT 方法論架構， 每個模組作為獨立的單元進行開發和測試。這種設計方法提高了系統的靈活性 和可維護性，便於對系統進行修改和擴展。此外，每個功能模組具有明確的邊界 和定義，確保系統運行的穩定性和可靠性。

---

![圖片：figure-37-21.jpg](images/figure-37-21.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## MIAT 方法論架構流程圖文字描述

這個 Grafcet 流程圖描述了MIAT方法論架構的執行流程，旨在將需求轉換為最終的程式碼。

**初始步驟：A0 (MIAT系統設計方法論)**

系統啟動後，首先進入 A0 步驟，代表著 MIAT 系統設計方法論的開始。此步驟處於致能狀態，表示系統正在等待接收「需求」輸入。當收到「需求」信號時，流程將從A0出發，進入下一步驟。

**主流程：需求分析與程式碼生成**

1.  **A1 (系統需求分析)**: 收到「需求」後，系統進入 A1 步驟進行「系統需求分析」。此步驟持續執行「系統需求分析」動作，直到完成分析為止。
2.  **A2 (系統架構設計)**: 完成「系統需求分析」後，流程轉移至 A2 步驟，開始執行「系統架構設計」。此步驟持續執行「系統架構設計」動作。
3.  **A3 (軟體事件建模)**: 「系統架構設計」完成後，系統進入 A3 步驟進行「軟體事件建模」。此步驟持續執行「軟體事件建模」動作。
4.  **A4 (高階軟體合成)**: 完成「軟體事件建模」後，流程轉移至 A4 步驟，開始執行「高階軟體合成」。此步驟持續執行「高階軟體合成」動作。

**分支結構分析：選擇性分支**

在 A4 步驟之後，存在一個橫線連接了兩個流程，這是一個**選擇性分支**。因為在橫線之後，每一條連接的分支流程都有其各自獨立的轉移條件（未顯示），系統會根據哪個條件首先被滿足來選擇一條路徑執行。

*   **分支 1：生成程式碼**: 從 A4 出發，流程可以進入「生成程式碼」步驟。
*   **分支 2：返回初始狀態**: 從 A4 出發，流程也可以直接返回 A0 步驟，表示系統完成一次循環，等待新的「需求」輸入。

**完整循環描述**

整個流程從接收「需求」開始，經過「系統需求分析」、「系統架構設計」、「軟體事件建模」、「高階軟體合成」，最終可以選擇生成程式碼或返回初始狀態等待下一個需求。如果選擇生成程式碼，則完成一次完整的MIAT方法論架構的執行循環；如果返回初始狀態，則表示系統準備處理新的需求，重新開始整個流程。

**總結**

這個 Grafcet 流程圖清晰地展示了 MIAT 方法論架構的核心步驟和流程，從需求分析到程式碼生成，以及可能的循環迭代過程。其選擇性分支結構允許根據具體情況靈活控制流程的走向，確保系統能夠高效、可靠地完成任務。

---

圖 3.3 IDEF0 表示 MIAT 方法論架構

階層式模組化設計有助於團隊分工合作，各模組之間的定義清晰明確，使來 自不同領域的專家能夠有效合作，進而提高系統設計的整體效率，並由於模組化 設計的特點，系統的各部分可以獨立開發和測試，縮短了開發周期，同時也便於 後續的系統擴展和升級，為各種新產品的快速開發提供解決方案。

## 3.1.2 Grafcet 離散事件建模

離散事件建模能夠詳細模擬和分析複雜系統中的事件和狀態變化，分析系 統中事件的發生和這些事件對系統狀態的影響，因為這些事件在時間軸上是離 散的，即在特定的時間點發生，而非連續發生，通過這種建模技術，可以深入理 解系統行為。

Grafcet 是一種用於描述和設計控制系統。通過其圖形化和結構化的表示方 法，主要組成為狀態(State)、轉移條件(Condition)、有向性的連結(Directed connection)，狀態是指離散系統所處的具體情況，行為描述了系統在該狀態下執 行的動作，轉移條件則是系統從一個狀態轉換到下一個狀態所需的條件，簡易 Grafcet 範例為如圖 3.4。

---

![圖片：figure-38-22.jpg](images/figure-38-22.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> 這個 Grafcet 流程圖實現了一個簡單的循序控制功能，包含初始狀態、子系統調用以及動作執行。

**1. 初始步驟 (Step 0)**

系統啟動或復位後，首先進入初始步驟 0，該步驟使用雙線方塊表示。在步驟 0 中，沒有相關聯的動作描述，代表系統處於待機狀態。

**2. 從步驟 0 到步驟 1 的轉移**

當滿足「Condition」這個轉移條件時，系統從步驟 0 轉移到步驟 1。根據 Grafcet 規則，步驟 0 會立刻變為非致能狀態 (Inactive)，而步驟 1 會立刻變為致能狀態 (Active)。

**3. 步驟 1 的執行與子系統調用**

在步驟 1 中，沒有相關聯的動作描述。同時，步驟 1 連接了一個「Sub-Grafcet」子系統。這表示當步驟 1 被致能後，會啟動並執行該子系統所定義的流程。子系統的具體行為需要參考其獨立的 Grafcet 圖表才能確定。

**4. 從步驟 1 到步驟 2 的轉移**

在完成「Sub-Grafcet」子系統的執行後（假設子系統執行完畢會觸發條件），當滿足「Condition」這個轉移條件時，系統從步驟 1 轉移到步驟 2。步驟 1 會立刻變為非致能狀態 (Inactive)，而步驟 2 會立刻變為致能狀態 (Active)。

**5. 步驟 2 的執行與動作執行**

在步驟 2 中，存在一個「Action」動作描述。這表示當步驟 2 被致能後，會持續執行該動作。具體的動作內容需要參考其詳細描述才能確定。

**6. 從步驟 2 返回初始步驟的轉移**

當滿足「Condition」這個轉移條件時，系統從步驟 2 轉移回初始步驟 0。步驟 2 會立刻變為非致能狀態 (Inactive)，而步驟 0 會再次變為致能狀態 (Active)。

**總結：**

整個流程圖描述了一個簡單的循序控制邏輯：系統從初始狀態啟動，經過一系列條件判斷後，執行子系統，然後執行一個動作，最後返回初始狀態。這個循環會不斷重複，直到滿足停止條件（未在圖中顯示）。由於每個步驟之間的轉移都依賴於相同的「Condition」條件，因此可以視為一個簡單的線性流程，並非分支結構。

---

圖 3.4 Grafcet 範例

Grafcet 狀態可分為三類分別為初始狀態(Initial state)、執行狀態(Inactive state)、閒置狀態(Active state)如 圖 3.5。初始狀態使用雙實線方塊呈現，執行狀 態為當下工作執行狀態，使用單實線方塊並由黑點標示，閒置狀態為未執行狀態， 使用單實線並無黑點標示。其中階層化設計中，行為方塊(Action)及子系統(Sub- Grafcet)分別表示狀態方塊執行動作或者執行內容較為複雜則可向下劃分子系統， 使系統架構更為清晰。

---

![圖片：figure-39-23.jpg](images/figure-39-23.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> 這個 Grafcet 流程圖實現了一個基於條件觸發的狀態機，用於執行一系列動作，包含子系統調用和特定行為的執行。

**初始步驟 (Step 0)**：系統啟動後，首先進入初始步驟 0（雙線方塊），表示系統處於待機或復位狀態。此時，沒有任何動作被執行。

**流程演進**: 從步驟 0 出發，存在一個通用的轉移條件 "轉移條件"。當這個“轉移條件”滿足時，系統會進入分支結構。

**分支判斷：選擇性分支**：在橫線之後，每個連接的分支流程都有其各自獨立的轉移條件，因此這是一個**選擇性分支**。系統會根據哪個條件首先被滿足來選擇一條路徑執行，各路徑是互斥的。

* **分支 1 (Step 1 – 子系統調用)**：如果“轉移條件”滿足且步驟 1 的獨立轉移條件也為真，則系統進入步驟 1，並執行 "子系統調用"（Sub-Grafcet）。這表示系統會呼叫一個更複雜的子流程來處理特定的任務。在步驟 1 完成後，如果其後的“轉移條件”滿足，則返回初始狀態。
* **分支 2 (Step 2 – 行為方塊)**：如果“轉移條件”滿足且步驟 2 的獨立轉移條件也為真，則系統進入步驟 2，並執行 "行為方塊"（Action）。這表示系統會執行一個特定的動作或操作。在步驟 2 完成後，如果其後的“轉移條件”滿足，則返回初始狀態。

**循環**: 無論是通過子系統調用還是行為方塊完成任務，當各自的步驟完成且其後的“轉移條件”滿足時，系統都會返回初始步驟 0，形成一個完整的循環。

**總結**: 這個 Grafcet 圖描述了一個簡單但有效的控制流程，它根據輸入的 "轉移條件" 和每個分支的獨立條件來選擇執行不同的任務（子系統調用或行為方塊）。系統在完成任務後會返回初始狀態，等待下一次觸發。

---

圖 3.5 (a)Grafcet 狀態表示 (b)Grafcet 行為方塊

綜整上述使用 Grafcet 進行離散事件建模可以使系統設計更易於分析，這有 助於理解和溝通行為，並結構化設計可以使系統更有條理，減少錯誤或遺漏的可 能性。

## 3.2 LLM 輔助生成 Grafcet action 程式碼

大型語言模型(Large Language Models, LLMs)是基於深度學習技術的自然語 言處理模型，擁有數十億參數，能夠理解並生成自然語言文本。這些模型利用龐 大的語料庫進行訓練，通過學習語言的結構和語義來進行文本生成和理解。LLM 的發展促使其在多個領域中取得了突破性進展，特別是在自動生成程式碼方面， 展現了極大的潛力和應用價值。

大 型 語 言 模 型 的 出 現 代 表 了 自 然 語 言 處 理 領 域 的 重 要 進 步 。 以 GPT(Generative Pre-trained Transformer)系列模型為代表，ChatGPT o1 模型是 OpenAI 推出的新一代大型語言模型，採用大規模強化學習與「思考鏈」(Chain of Thought)技術進行訓練，模型在生成答案前執行多步推理，並在輸出中顯示完 整的推理過程[58]。該模型旨在複雜推理任務中提升準確性，還使其回答具備更

強的可解釋性，同時增強模型對安全性與指令遵從的能力。在訓練過程中，o1 模 型利用多元數據來源，包括公開的網頁數據、科學文獻，以及合作夥伴提供的專 有數據集，確保模型的知識覆蓋範圍廣泛且專業。此外，OpenAI 開發了嚴格的 數據處理管道，通過篩選、拒絕有害內容和安全分類器過濾，降低訓練數據中個 人信息或敏感內容的風險[59]。

這些模型的強大性能主要來自於兩個方面：一是龐大的訓練數據，涵蓋了各 種主題和語言；二是深度神經網絡架構，允許模型學習複雜的語言模式和結構。 通過這些優勢，LLM 在各種自然語言處理任務中，如文本生成、機器翻譯、問 答系統等，都展現出了卓越的性能。

然而，自動生成程式碼是 LLM 的一個重要應用領域，旨在將自然語言描述 轉換為可執行的程式碼。這一技術在提高開發效率、減少錯誤以及促進創新方面 具有重要意義。

LLM 還能生成高質量的程式碼，提高可讀性和可維護性。Liu 等人(2023)的 研究系統性地評估了 ChatGPT 在生成程式碼方面的表現，發現其在正確性、可 理解性和安全性方面具有較好的性能[60]。LLM 生成的程式碼不僅能提高效率， 還能減少人為錯誤。Huang 等人(2023)提出了一個針對程式碼生成任務的偏見評 估框架，並指出 LLM 生成的程式碼中存在一定比例的偏見，但通過適當的策略 可以有效減少這些偏見[61]。

## 3.3 可重構指紋特徵比對系統架構設計

本論文研究主要提出可依照使用者需求選擇特徵比對演算法的模組化系統 架構，透過 MIAT 方法論進行 IDEF0 模組階層規劃、Grafcet 離散事件建模，進 而整合至指紋辨識系統(A0)中，如圖 3.6，完成使用者可配和各場景及需求切換

---

![圖片：figure-41-24.jpg](images/figure-41-24.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容，進行詳細的系統架構分析與描述。

**層級關係:** 此圖表為頂層圖表 (A0)。

**模組列表及資訊流分析:**

1.  **模組編號 1: 指紋影像增強 (Fingerprint Image Enhancement) - A1**
    *   **輸入:**
        *   測試指紋 (來自外部來源)
        *   樣本指紋 (來自外部來源)
    *   **輸出:**
        *   增強後的指紋 (流至 模組 A2)

2.  **模組編號 2: 指紋特徵點提取 (Minutiae Extraction) - A2**
    *   **輸入:**
        *   增強後的指紋 (來自 模組 A1 的輸出)
    *   **輸出:**
        *   特徵點 (流至 模組 A3)

3.  **模組編號 3: 指紋核心點及分叉點偵測 (Singular Points Detection) - A3**
    *   **輸入:**
        *   特徵點 (來自 模組 A2 的輸出)
    *   **輸出:**
        *   核心點/分叉點資訊 (流至 模組 A4)

4.  **模組編號 4: 指紋比對 (Minutia Matching) - A4**
    *   **輸入:**
        *   核心點/分叉點資訊 (來自 模組 A3 的輸出)
    *   **輸出:**
        *   最終相似度 (流至 外部)

**總結:**

此圖表(A0)展示了指紋辨識系統的頂層架構，包含四個主要模組：指紋影像增強、指紋特徵點提取、指紋核心點及分叉點偵測以及指紋比對。資訊流從測試和樣本指紋開始，經過一系列處理步驟，最終輸出相似度結果。每個模組的輸入來自前一個模組的輸出或外部來源，輸出則傳遞至後續模組或外部系統。根據上下文，A4為指紋辨識系統(A0)中的一個模組，並進一步分層為三個子系統。

---

圖 3.6 指紋辨識系統 IDEF0 模組階層規劃

指紋特徵比對模組為指紋辨識系統(A4)模組中的一個模組，並進一步分層為 三個子系統，分別為旋轉排除、線段方向排除、特徵比對模組，首先上層輸入樣 本特徵及測試特徵，進行旋轉排除(A41)演算法排除後，將解析傳遞予線段方向 排除(A42)進行演算法排除，經處理後傳至特徵比對(A43)進行比對分析，最終取 得相似度。

## 3.3.1 指紋比對模組(A4)

本研究中，使用 IDEF0 技術來進行指紋比對模組(A4)規劃，如圖 3.7 所示。 該子模組包括三個功能模組，分別是線段旋轉排除(A41)、線段方向排除(A42)和 特徵點比對(A43)。

首先，線段旋轉排除(A41)功能模組負責根據指紋的旋轉特徵進行排除。這 一過程的輸入是指紋圖像資料和相關的旋轉特徵數據，輸出為已經排除不符合 旋轉條件的指紋數據。接下來是線段方向排除(A42)功能模組。該模組對指紋線 段的方向和特徵進行分析和排除。輸入為指紋圖像資料和相關的線段特徵數據， 輸出為已經排除不符合條件的線段數據。

最後是特徵點比對(A43)功能模組。該模組根據前述排除過程得到的指紋數 據進行詳細的特徵比對。輸入為已經排除不符合條件的指紋數據和線段數據，輸 出為最終的相似度值。

---

![圖片：figure-42-25.jpg](images/figure-42-25.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容進行分析，並以繁體中文呈現結果：

**層級關係:** 此圖表為父圖 A0 中，模組 A4 的詳細分解。

**模組列表與資訊流分析:**

1.  **模組編號 1: 線段旋轉排除 (Relative rotation elimination, A41)**
    *   輸入：
        *   指紋圖像資料 (來自外部來源)
        *   測試特徵點 (來自外部來源)
    *   輸出：
        *   已排除的指紋數據 (流至 模組 A42 和 A43)

2.  **模組編號 2: 線段方向排除 (Relative translation elimination, A42)**
    *   輸入：
        *   指紋圖像資料 (來自外部來源)
        *   測試特徵點 (來自外部來源)
        *   已排除的指紋數據 (來自 模組 A41 的輸出)
    *   輸出：
        *   已排除的線段數據 (流至 模組 A43)

3.  **模組編號 3: 特徵點比對 (Final comparison, A43)**
    *   輸入：
        *   已排除的指紋數據 (來自 模組 A41 的輸出)
        *   已排除的線段數據 (來自 模組 A42 的輸出)
    *   輸出：
        *   最終相似度值 (流至 外部)

**總結:**

圖表A4詳細分解了指紋比對模組的功能，包含三個子模組：線段旋轉排除(A41)、線段方向排除(A42)和特徵點比對(A43)。  資料流程從外部輸入的指紋圖像資料和測試特徵點開始，經過A41和A42的排除過程後，傳遞至A43進行最終的比對，並輸出相似度值。 整個過程體現了逐步篩選和比對的邏輯。

---

圖 3.7 指紋比對模組(A4)

## 3.3.2 線段旋轉排除模組(A41)

本研究使用 IDEF0 來規劃旋轉排除模組如圖 3.8 所示，該子模組分別為七 個功能模組為兩線段相似值比較(A411)、特徵點種類(A412)、特徵點曲率(A413)、 特徵點的平均脊密度(A414)、構成旋轉直方圖(A415)、旋轉確認(A416)、旋轉排 除(A417)。

---

![圖片：figure-43-26.jpg](images/figure-43-26.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容進行分析，並以繁體中文呈現一份詳細的報告。

**層級關係:** 此圖表為父圖 A0 中，模組 A41 的詳細分解。

---

**系統架構分析：線段旋轉排除模組 (A41)**

本圖表描述了線段旋轉排除模組(A41)的內部結構與資訊流動。該模組由七個子模組組成，分別為兩線段相似值比較(A411)、特徵點種類(A412)、特徵點曲率(A413)、特徵點的平均脊密度(A414)、構成旋轉直方圖(A415)、旋轉確認(A416)和旋轉排除(A417)。

**子模組分析:**

*   **1. 兩線段相似值比較 (A411):**
    *   **輸入:** 指紋線段資料 (來自外部來源)
    *   **輸出:** 相似性評估結果 (流至 A412)

*   **2. 特徵點種類 (A412):**
    *   **輸入:** 相似性評估結果 (來自 A411 的輸出)
    *   **輸出:** 特徵點類型列表 (流至 A413)

*   **3. 特徵點曲率 (A413):**
    *   **輸入:** 特徵點類型列表 (來自 A412 的輸出)
    *   **輸出:** 特徵點曲率數值 (流至 A414)

*   **4. 特徵點的平均脊密度 (A414):**
    *   **輸入:** 特徵點曲率數值 (來自 A413 的輸出)
    *   **輸出:** 特徵點平均脊密度值 (流至 A415)

*   **5. 構成旋轉直方圖 (A415):**
    *   **輸入:** 特徵點平均脊密度值 (來自 A414 的輸出)
    *   **輸出:**  (流至 A416)

*   **6. 旋轉確認 (A416):**
    *   **輸入:**  (來自 A415 的輸出)
    *   **輸出:** (流至 A417)

*   **7. 旋轉排除 (A417):**
    *   **輸入:** (來自 A416 的輸出)
    *   **輸出:**  測試結果 (流至外部)

---

**總結：**

線段旋轉排除模組(A41)通過一系列子模組的串聯處理，對指紋線段資料進行分析和比較，最終實現旋轉排除功能。每個子模組都接收來自前一個模組的輸出作為輸入，並將其結果傳遞給下一個模組，形成一個完整的資訊流動鏈條。此圖表清晰地展示了該模組內部各個功能的分解與協同工作方式。

---

圖 3.8 線段旋轉排除模組(A41)

在兩線段相似比較(A411)功能模組中，系統比較兩條指紋線段的相似性。這 一步的輸入為指紋線段資料，輸出則是相似性評估結果。接下來，進行特徵點種 類(A412)的識別和分類。系統輸入指紋特徵點資料，通過系統識別並分類指紋中 的特徵點類型，輸出為特徵點類型列表，依據特徵點識別標準進行控制。隨後， 系統計算特徵點的曲率(A413)。這一步驟以指紋特徵點資料為輸入，通過讀取特 徵點的曲率數值進行分類。特徵點的平均脊密度(A414)計算是下一步驟。系統讀 取特徵點資料，分類出特徵點的平均脊密度值。

在完成上述計算後，系統根據特徵點和線段相似性結果，構成旋轉直方圖 (A415)。這一步的輸入是相似性評估結果和特徵點資料，輸出則為旋轉直方圖。

旋轉確認(A416)功能模組負責確認是否尚有未處理的特徵點。系統以旋轉直方圖 為輸入，輸出確認的旋轉點，通過比對系統進行確認。

最後，旋轉排除(A417)模組排除不符合條件的旋轉點。確認的旋轉點作為 輸入，系統進行排除過程，輸出剩餘的旋轉點，由排除模組實現，並依據排除 標準進行。

## 3.3.3 線段方向排除模組(A42)

線段方向排除模組(A42)如圖 3.9 該子模組分別為四個功能模組為線段方向 差異測試(A421)、構成平移直方圖(A422)、線段判斷(A423)、線段排除(A424)。 在線段方向差異測試(A421)功能模組中，系統進行兩條指紋線段的方向差異測試。 這一過程的輸入是指紋線段資料，輸出為方向差異測試結果。接著，根據方向差 異測試的結果，系統在構成平移直方圖(A422)模組中生成平移直方圖。這一步驟 的輸入是方向差異測試結果，輸出則為平移直方圖。

---

![圖片：figure-44-27.jpg](images/figure-44-27.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容進行分析，並以繁體中文呈現詳細的描述。

**層級關係:** 此圖表為父圖 A0 中，模組 A42 的詳細分解。

**子模組分析:**

1.  **模組編號 1: 線段方向差異測試 (Line orientation difference test, A421)**
    *   **輸入:**
        *   (來自 外部來源) - 標籤：線條特徵數據
    *   **輸出:**
        *   (流至 模組 A422) - 標籤：方向差異測試結果

2.  **模組編號 2: 構成平移直方圖 (Formation of the translation histograms, A422)**
    *   **輸入:**
        *   (來自 模組 A421 的輸出) - 標籤：方向差異測試結果
    *   **輸出:**
        *   (流至 模組 A423) - 標籤：平移直方圖

3.  **模組編號 3: 線段判斷 (Translation determination, A423)**
    *   **輸入:**
        *   (來自 模組 A422 的輸出) - 標籤：平移直方圖
    *   **輸出:**
        *   (流至 模組 A424) - 標籤：線段判斷結果

4.  **模組編號 4: 線段排除 (Translation elimination, A424)**
    *   **輸入:**
        *   (來自 模組 A423 的輸出) - 標籤：線段判斷結果
    *   **輸出:**
        *   (流至 外部來源) - 標籤：線條特徵數據

**總結:**

圖表A42描述了線段方向排除模組的詳細流程。該模組包含四個子模組，分別為線段方向差異測試、構成平移直方圖、線段判斷和線段排除。系統首先對線條特徵數據進行方向差異測試，然後根據測試結果生成平移直方圖，再利用平移直方圖進行線段判斷，最後完成線段排除並輸出結果。整個流程呈現出一個清晰的資訊流動鏈，從輸入數據到最終輸出結果，每個子模組都扮演著特定的角色。

---

圖 3.9 線段方向排除模組(A42)

隨後，在線段判斷(A423)功能模組中，系統根據平移直方圖進行線段判 斷。系統以平移直方圖為輸入，輸出為線段判斷結果。該過程由判斷系統實

* 現，並依據判斷標準進行控制。

最後，在線段排除(A424)功能模組中，系統根據判斷結果排除不符合條件 的線段。確認的線段判斷結果作為輸入，系統進行排除過程，輸出為剩餘的線 段。該功能由排除模組實現，並依據排除標準進行控制。

## 3.3.4 特徵點比對模組(A43)

特徵點比對(A43)如圖 3.10 該子模組分別為三個功能模組為線段端點差異 測試(A431)、不良特徵點比對排除(A432)、相似度計算(A433)。

---

![圖片：figure-45-28.jpg](images/figure-45-28.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容，進行分析並提供詳細的描述。

**層級關係:** 此圖表為父圖 A0 中，模組 A43 的詳細分解。

**子模組列表:**

*   A431: 線段端點差異測試 (Lines ends difference test)
*   A432: 不良特徵點比對排除 (Elimination of false matched pairs)
*   A433: 相似度計算 (Final similarity calculation)

**子模組分析:**

**1. A431: 線段端點差異測試 (Lines ends difference test)**

*   **輸入 (Input):**
    *   基本特徵點資料，測試結果 (來自外部來源)
*   **輸出 (Output):**
    *   線段端點差異測試結果 (流至 A432, 流至 A433)

**2. A432: 不良特徵點比對排除 (Elimination of false matched pairs)**

*   **輸入 (Input):**
    *   線段端點差異測試結果 (來自 A431 的輸出)
*   **輸出 (Output):**
    *   最終相似度 (流至 A433)

**3. A433: 相似度計算 (Final similarity calculation)**

*   **輸入 (Input):**
    *   線段端點差異測試結果 (來自 A431 的輸出)
    *   最終相似度 (來自 A432 的輸出)
*   **輸出 (Output):**
    *   最終相似度 (流至 外部)

**總結:**

特徵點比對模組(A43)包含三個子模組：線段端點差異測試(A431)、不良特徵點比對排除(A432)和相似度計算(A433)。  A431 負責初步的端點差異測試，其輸出作為 A432 的輸入，用於排除錯誤的比對。A432 的輸出與 A431 的輸出共同作為 A433 的輸入，最終完成相似度的計算。整個模組的最終結果輸出至外部系統。

---

圖 3.10 特徵點比對模組(A43)

首先，在線段端點差異測試(A431)功能模組中，系統對兩條指紋線段的端點 差異進行測試。這一過程的輸入是指紋線段資料，輸出為端點差異測試結果。

接下來，不良特徵點比對排除(A432)功能模組負責根據端點差異測試結果， 消除不符合條件的錯誤比對。系統輸入端點差異測試結果，輸出為不良特徵點比 對排除後的結果。這一步驟依據錯誤比對排除標準進行控制，由比對排除模組來 實現。

最後，在相似度計算(A433)功能模組中，系統根據不良特徵點比對排除後的 結果，計算指紋之間的相似度。系統輸入不良特徵點比對排除的結果，輸出為相 似度值。相似度計算過程依據相似度計算標準進行。

## 3.4 離散事件建模

在本研究中，使用離散事件模型來描述指紋特徵比對的過程，如圖 3.11 所 示。首先，系統輸入測試指紋並對其進行影像增強處理。這一步在離散事件模型 中被建模為一個初始事件，該事件完成後，會觸發兩個平行的事件：指紋核心點 偵測和指紋特徵點擷取。指紋核心點偵測和指紋特徵點擷取是並行進行的，這 意味著這兩個過程可以同時執行而不互相干擾。在核心點處理過程中，系統識 別並處理指紋的核心點，這對後續的比對至關重要。特徵點擷取過程則負責識 別和擷取指紋中的細節特徵點，如特徵點和端點。

當指紋核心點偵測和指紋特徵點擷取均完成後，這兩個平行事件會觸發下 一個關鍵事件，即指紋比對。指紋比對是整個指紋辨識系統過程的最後一步，在 這一步中，系統將樣本指紋與測試指紋的特徵點進行詳細比對計算並輸出相似 度數值。該數值表示樣本指紋與測試指紋之間的相似程度。

---

![圖片：figure-46-29.jpg](images/figure-46-29.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## 指紋辨識系統流程描述 (基於 Grafcet 圖表)

本 Grafcet 流程圖描述了指紋辨識系統的完整比對過程，從輸入測試指紋開始，經過影像增強、特徵點偵測與擷取，最終完成指紋比對並輸出相似度數值。

**1. 初始狀態 (步驟 0)**

系統處於待機狀態（步驟 0）。此時，沒有任何動作執行。當「測試特徵點 == 1」的條件滿足時，即輸入了測試指紋，系統會從步驟 0 轉移到步驟 1。

**2. 指紋影像增強 (步驟 1)**

步驟 1 代表指紋影像增強處理。一旦進入步驟 1，系統開始執行「指紋影像增強」動作。只要步驟 1 處於致能狀態，此動作就會持續執行。當「影像增強完成 == 1」的條件滿足時，表示影像增強處理完成，系統會觸發下一步驟的啟動。

**3. 並行分支：核心點偵測與特徵點擷取 (步驟 2 & 3)**

當步驟 1 完成後，系統進入一個並行分支。這是因為從步驟 1 出發，橫線之前有一個共通條件「影像增強完成 == 1」，因此步驟 2（指紋核心點偵測）和步驟 3（指紋特徵點擷取）會**同時啟動**。

*   **步驟 2：指紋核心點偵測**
    系統開始執行「指紋核心點偵測」動作，持續進行直到「特徵點擷取 == 1」的條件滿足。
*   **步驟 3：指紋特徵點擷取**
    系統開始執行「指紋特徵點擷取」動作，持續進行直到「特徵點擷取 == 1」的條件滿足。

**4. 指紋比對 (步驟 4)**

當步驟 2 和步驟 3 **同時完成**（即兩個步驟都處於致能狀態且各自滿足了轉移條件），系統會進入步驟 4，執行「指紋比對」動作。此步驟將樣本指紋與測試指紋的特徵點進行詳細比對計算並輸出相似度數值。

**5. 完成循環 (步驟 4)**

一旦步驟 4 完成，且滿足「指紋比對完成 == 1」的條件，系統會返回初始狀態（步驟 0），等待下一次測試指紋的輸入，開始新的循環。

**總結：**

整個流程圖描述了一個並行處理架構，在影像增強後，核心點偵測和特徵點擷取同時進行，完成後再執行比對計算。系統通過不斷循環，實現持續的指紋辨識功能。此設計優勢在於可以提高整體效率，縮短比對時間。

---

圖 3.11 指紋辨識系統離散事件建模

## 3.4.1 指紋特徵比對離散事件模型

指紋比對在進行子系統擴充建立離散事件模型，如圖 3.12 所示，首先，將樣 本指紋及測試指紋輸入系統。隨後對這兩組指紋進行旋轉角度的比對，排除因旋 轉角度不同而不配對的指紋，以減少角度偏差導致的誤差。這一過程在離散事件 模型中被建模為一個事件，該事件在角度比對完成時觸發，並輸出比對結果。旋 轉比對完成後，系統進一步對指紋的線段方向進行比對排除。這一過程在離散事 件模型中被建模為另一個事件，該事件在線段方向比對完成時觸發，進而輸出比 對結果。這一過程旨在通過精細比對指紋的線段特徵，提高比對的準確度。在線 段方向比對完成後，系統會對指紋的特徵進行詳細比對。最終計算並輸出指紋之 間的相似度數值。該數值表示樣本指紋與測試指紋之間的比對程度，並被模型中

的最後一個事件所觸發。

---

![圖片：figure-47-30.jpg](images/figure-47-30.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## 指紋比對離散事件模型流程描述

本 Grafcet 流程圖實現了指紋比對的完整流程，包含旋轉角度比對、線段方向比對以及特徵詳細比對，最終輸出相似度數值。

**步驟 40：初始狀態 (待機)**

系統初始化後，進入步驟 40 的待機狀態。此時，系統處於空閒狀態，等待接收樣本指紋和測試指紋的輸入。

**流程演進：**

當「讀取樣本、測試特徵點 == 1」條件滿足時，表示系統已成功接收到樣本指紋和測試指紋，步驟 40 轉移至步驟 41。

**步驟 41：旋轉角度排除**

步驟 41 代表對輸入的樣本指紋和測試指紋進行旋轉角度比對，以排除因角度差異導致的不匹配情況。在步驟 41 中執行「線段方向排除」動作。

**流程演進：**

當「旋轉比對完成 == 1」條件滿足時，表示旋轉角度比對已完成，系統轉移至步驟 42。

**步驟 42：線段方向比對**

步驟 42 代表對經過旋轉角度比對後的指紋進行線段方向比對，進一步提高比對準確度。在步驟 42 中執行「線段方向排除」動作。

**流程演進：**

當「線段方向比對完成 == 1」條件滿足時，表示線段方向比對已完成，系統轉移至步驟 43。

**步驟 43：特徵點比對**

步驟 43 代表對經過旋轉角度和線段方向比對後的指紋進行詳細的特徵點比對，計算樣本指紋和測試指紋之間的相似度數值。在步驟 43 中執行「特徵點比對」動作。

**流程演進：**

當「相似度數值 == 1」條件滿足時，表示特徵點比對已完成，系統輸出最終的相似度數值。此時，整個指紋比對流程結束，系統返回初始狀態（步驟40），等待下一次輸入。

**總結：**

該 Grafcet 圖描述了一個順序的指紋比對流程。系統從接收樣本和測試指紋開始，依次進行旋轉角度比對、線段方向比對以及特徵點比對，最終輸出相似度數值。每個步驟都依賴於前一個步驟完成後觸發的條件，形成一個完整的循環。整個流程沒有分支結構，因此系統按照固定的順序執行所有步驟。

---

圖 3.12 指紋比對離散事件建模

## 3.4.2 線段旋轉排除離散事件模型

將指紋特徵比對過程中的旋轉角度比對排除子系統進行離散事件建模，如圖 3.13 所示，首先計算兩線段指紋線段的相似性，這一過程被建模為一個初始事 件，完成後觸發特徵點的種類計算，識別並分類不同類型的特徵點。系統計算特 徵點的曲率，確定指紋紋路的彎曲程度，接著計算特徵點平均脊密度，這些計算 結果有助於更精確地進行指紋特徵比對，系統將這些結果用於建立旋轉直方圖。 該事件完成後驗證是否尚有旋轉點未計算，若存在未計算的旋轉點，系統將重複 上述計算過程，直至所有旋轉點計算完成。確認所有旋轉點的計算完成，在進行 旋轉角度判斷，以排除不符合條件的旋轉點。這一過程確保只保留最符合條件的 旋轉點，從而提高比對的準確性。

---

![圖片：figure-48-31.jpg](images/figure-48-31.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## 指紋旋轉角度比對排除子系統流程描述

本 Grafcet 流程圖實現了指紋特徵比對過程中，針對旋轉角度的排除功能，旨在提高比對準確性。

**1. 初始狀態 (步驟 410)**

系統初始化時，進入步驟 410 “取得資料集 == 1”。此步驟代表系統已準備好輸入指紋資料進行處理，且“取得資料集”的條件為真，表示資料集已成功載入。

**2. 特徵點計算流程 (步驟 411 - 415)**

*   從步驟 410 進入步驟 411 “兩線段相似性計算”。此步驟執行兩線段指紋線段的相似性計算，完成後“相似性計算完成 == 1”條件成立。
*   接著，系統進入步驟 412 “特徵點種類分類”，進行特徵點的識別和分類，完成後“分岔點計算完成 == 1”。
*   隨後，系統執行步驟 413 “特徵點過濾”，對特徵點進行過濾處理，完成後“曲線計算完成 == 1”。
*   步驟 414 “特徵點的平均脊密度”計算特徵點平均脊密度，完成後“脊密度計算完成 == 1”。
*   最後，系統執行步驟 415 “構成旋轉直方圖”，基於前述計算結果建立旋轉直方圖。

**3. 分支結構判斷：選擇性分支**

在步驟 415 後，流程經過一條橫線後連接了兩個流程（步驟 416 和步驟 417）。根據 Grafcet 規則總綱第 4 條，由於橫線之後的每個分支流程都有各自獨立的轉移條件，因此這是一個**選擇性分支**。系統會根據“尚有旋轉點未計算 == 1”或“旋轉點計算完成 == 1”的條件來選擇執行哪個路徑。

**4. 分支一：繼續計算 (步驟 416)**

*   如果 “尚有旋轉點未計算 == 1”，系統進入步驟 416 “比較下一個旋轉點”。此步驟用於判斷是否還有未計算的旋轉點，完成後“下一個旋轉點 == 1”條件成立。
*   然後，流程返回步驟 410 “取得資料集 == 1”，重新開始特徵點計算流程，形成循環，直到所有旋轉點都被計算完成。

**5. 分支二：旋轉角度判斷 (步驟 417 - 418)**

*   如果 “旋轉點計算完成 == 1”，系統進入步驟 417 “旋轉點角度判斷”。此步驟執行旋轉角度的判斷，排除不符合條件的旋轉點。
*   接著，系統執行步驟 418 “旋轉點排除”，將不符合條件的旋轉點從結果中移除，完成後“旋轉點排除完成 == 1”條件成立。

**6. 循環結束與整體流程**

在步驟 418 完成後，流程結束。整個系統的工作循環包括：資料集取得、特徵點計算、選擇性分支判斷（繼續計算或角度判斷）、以及旋轉點排除。通過不斷循環計算和判斷，最終完成指紋旋轉角度的排除，提高比對準確性。

**總結:**

此 Grafcet 流程圖描述了一個迭代式的指紋旋轉角度比對排除系統。系統首先進行一系列特徵點計算，然後根據是否還有未計算的旋轉點，選擇繼續計算或進行角度判斷和排除操作。整個過程通過循環執行，確保所有旋轉點都被處理，最終得到最符合條件的旋轉點集合。

---

圖 3.13 旋轉排除離散事件建模

## 3.4.3 線段方向排除離散事件模型

首先，系統對兩條指紋線段的方向差異進行運算，完成後觸發下一個事件， 即構成平移直方圖。根據方向差異的計算結果，該直方圖用於分析和比對指紋特 徵的線段方向。

接著，系統檢查是否存在尚未運算的線段。如果存在未運算的線段，系統將 重複方向差異運算和構成平移直方圖的過程，直至所有線段的運算完成。這一過 程在離散事件模型中被建模為一個迭代過程，確保對所有指紋線段進行全面的 分析和比對，並當所有線段的運算完成後，系統進行線段比對排除。

---

![圖片：figure-49-32.jpg](images/figure-49-32.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## 指紋線段方向排除離散事件模型 – Grafcet 文字描述

這個 Grafcet 流程圖實現了指紋線段方向差異運算、直方圖構建以及基於直方圖的線段比對排除功能，確保所有指紋線段都經過分析和比對。

**1. 初始步驟 (Step 420):**

系統初始化後，進入步驟 420 的待機狀態。此時，`旋轉比較完成 == 1` 為假，步驟 420 非致能狀態。當 `旋轉比較完成 == 1` 條件滿足時（表示指紋線段方向差異運算已完成），步驟 420 被致能，系統開始執行下一步驟。

**2. 方向差異運算與直方圖構建 (Step 421 – Step 422):**

*   **步驟 421:** 一旦步驟 420 致能，系統進入步驟 421，執行「線段方向差異計算」。此時 `差異運算完成 == 1` 為假。
*   **步驟 422:** 當步驟 421 完成後，`差異運算完成 == 1` 條件滿足，系統進入步驟 422，執行「構成平移直方圖」動作。

**3. 分支結構分析：選擇性分支**

在步驟 422 之後，流程線經過一條橫線後分成了兩個分支。根據 Grafcet 規則總綱第 4 條的判斷，此處為**選擇性分支**，因為每個分支都有其獨立的轉移條件。系統會根據哪個條件首先滿足來決定執行哪一個分支。

**4. 分支一：線段比對排除 (Step 423):**

*   **步驟 423:** 如果 `尚有線段未計算 == 1` 條件為真，則系統進入步驟 423，執行「比較下一個線段點」。
*   **下一步驟：** 當步驟 423 完成後，`下一線段 == 1` 條件滿足，流程返回步驟 420，重新開始方向差異運算與直方圖構建的循環。

**5. 分支二：線段比對排除 (Step 424 – Step 425):**

*   **步驟 424:** 如果 `直方圖運算完成 == 1` 條件為真，則系統進入步驟 424，執行「線段判斷」。此時 `線段判斷完成 == 1` 為假。
*   **步驟 425:** 當步驟 424 完成後，`線段判斷完成 == 1` 條件滿足，系統進入步驟 425，執行「線段排除」動作。

**6. 循環與終止：**

無論是通過分支一還是分支二，最終都會返回到步驟 420 的待機狀態。分支一的迴路確保了所有指紋線段都經過方向差異運算和直方圖構建。分支二則負責基於直方圖進行線段比對排除。

當所有線段的比對排除完成後，`旋轉比較完成 == 1` 條件再次滿足，系統進入下一個循環或終止狀態（具體取決於更上層的控制邏輯）。

**總結：**

這個 Grafcet 流程圖描述了一個迭代過程，用於分析和比對指紋線段的方向差異。它通過方向差異運算、直方圖構建以及基於直方圖的線段比對排除，確保了對所有指紋線段進行全面的分析和比對。選擇性分支結構允許系統根據不同的條件執行不同的流程，實現靈活的控制邏輯。

---

圖 3.14 線段方向排除離散事件建模

## 3.4.4 特徵點比對離散模型

首先針對對兩條指紋線段的端點差異進行測試，這一步被建模為初始事件， 完成後觸發不良特徵點比對排除事件。不良特徵點比對排除過程中，系統根據端 點差異測試的結果，排除那些不符合條件的線段，以減少比對過程中的誤差和錯 誤配對。

接下來，檢查是否存在尚未計算的線段端點，如果存在未計算的線段端點， 系統將重複端點差異測試和不良特徵點比對排除的過程，直至所有線段端點計 算完成，確保對所有指紋線段端點進行全面的分析和比對。

當所有線段端點計算完成後，系統進行相似度計算。此步驟根據前述不良特 徵點比對排除的結果，計算樣本指紋與測試指紋之間的相似度。這一過程被建模 為最終事件，並輸出相似值，該相似值表示指紋之間的比對程度。

---

![圖片：figure-50-33.jpg](images/figure-50-33.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## 指紋特徵比對流程描述

這個 Grafcet 流程圖實現了指紋特徵的比對過程，從方向性比對開始，逐步進行端點差異測試、不良特徵點排除，最終計算樣本與測試指紋的相似度。

**初始步驟 (430)**：系統處於待機狀態，等待「線段方向性比對完成」條件為真（== 1）。當此條件滿足時，流程開始執行。

**步驟 431 – 線段端點差異測試**: 一旦「線段方向性比對完成」條件成立，系統進入步驟 431，進行「線段端點差異測試」。

**步驟 432 – 不良特徵點比對排除**: 完成「線段端點差異測試」後，系統進入步驟 432，執行「不良特徵點比對排除」操作。

**分支結構分析：選擇性分支**

在步驟 432 後，流程經過一條橫線連接了兩個不同的路徑。根據 Grafcet 規則總綱第 4 條的判斷，此處為**選擇性分支**。因為橫線之後的每個分支都有其各自獨立的轉移條件：
*   「尚有線段端點未計算」條件 (== 1)
*   「誤差比對完成」條件 (== 1)

因此，系統會根據哪個條件首先滿足來選擇執行其中一個路徑。

**分支一：處理尚未計算的線段端點 (433)**

如果「尚有線段端點未計算」條件為真（== 1），則系統進入步驟 433，執行「比較下一個端點」。
*   **步驟 433 – 比較下一個端點**:  執行完此步驟後，流程返回到步驟 430，等待「線段方向性比對完成」條件再次成立，開始下一輪的端點差異測試和不良特徵點排除。

**分支二：進行相似度計算 (434)**

如果「誤差比對完成」條件為真（== 1），則系統進入步驟 434，執行「相似度計算」。
*   **步驟 434 – 相似度計算**:  執行完此步驟後，流程返回到步驟 430，等待「線段方向性比對完成」條件再次成立。

**循環過程：**

整個流程形成一個循環：系統首先進行方向性比對，然後測試端點差異並排除不良特徵點。如果還有未計算的端點，則重複此過程；否則，執行相似度計算。當所有線段端點都計算完成後，系統輸出最終的相似值，表示指紋之間的比對程度。

**總結：**

這個 Grafcet 流程圖清晰地描述了一個迭代式的特徵比對流程，通過不斷測試和排除，最終實現精確的相似度計算。選擇性分支結構允許系統根據實際情況靈活地處理不同狀態下的端點數據，確保了比對過程的完整性和準確性。

---

圖 3.15 特徵比對離散事件建模

## 第四章、 可重構指紋特徵比對實驗

本章首先介紹實驗環境、所使用的 FVC2004 資料庫、評估方法、指紋特徵 比對方法。最後，將進行實驗結果的分析，對指紋比對的性能進行評估，並驗證 指紋特徵比對架構的有效性。本章旨在通過實驗驗證指紋比對系統中模組化設 計的性能，並測試大語言模型(LLM)生成系統架構程式碼的準確性與效率。實驗 目的是確認系統可快速更換演算法及指紋影像情況下的穩定性與表現。

## 4.1 實驗環境

本研究的實驗環境如表 4.1，建立在 Windows 作業環境，編譯器使用 Visual Studio 提供了多樣的工具和功能，能夠支援建立 C++主控台應用程式。應用程式 的編譯和測試工作也都在這個環境中完成。在數據庫方面，使用的是 Liao[62]研 究中的指紋特徵點擷取程式，將圖片中的特徵點擷取出來，並且輸出成 CSV 檔。

## 表 4.1 實驗環境規格

**📊 表格內容：**

<table><thead><tr><th>CPU</th><th>Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz</th></tr></thead><tbody><tr><td>記憶 體</td><td>16 GB</td></tr><tr><td>作業 系 統</td><td>Microsoft Windows 10</td></tr><tr><td>編譯 器</td><td>Visual studio</td></tr></tbody></table>

## 4.2 資料描述

FVC2004(Fingerprint Verification Competition 2004)是指紋識別領域內的重 要資料集之一，旨在為學術界和工業界提供一個標準化的平台，用於評估指紋識 別算法的性能。FVC2004 資料集包含四個不同的資料庫(DB1、DB2、DB3、DB4)， 每個資料庫包含不同影像品質和類型的指紋圖像[63]，如表 4.2。

表 4.2 FVC2004 資料集說明

**📊 表格內容：**

<table><thead><tr><th>資料 庫</th><th>「 感 應 器 型 別</th><th>圖 片 解析 度</th><th>圖 片 尺寸</th></tr></thead><tbody><tr><td>DBI</td><td>光學 感 測 器 /V3007”</td><td>640x480</td><td>500dpi</td></tr><tr><td>DB2</td><td>光學 感 測 器 ”U.are.U4000”</td><td>328x364</td><td>500dpi</td></tr><tr><td>DB3</td><td>熱 掃描 感 測 器</td><td>300x480</td><td>512dpi</td></tr><tr><td>DB4</td><td>合成 指紋 圖 片</td><td>288x384</td><td>約 500dpi</td></tr></tbody></table>

FVC2004 資料集的特點包括多樣性、真實性、合成數據和標準化。該資料 集包含了來自不同掃描儀類型和不同品質的指紋圖像，提供了豐富的多樣性。前 三個數據庫是真實的指紋圖像，真實反映了在實際應用中的表現，例如按壓感測 器垂直位置的不同、手指壓力不同、手指乾燥程度，而第四個數據庫由合成指紋 圖像組成，如圖 4.1 所示。每個資料庫庫包含 10 位指紋志願者(編號 101~編號 110)，每個志願者提供每隻手指 8 個指紋印，共 80 個指紋圖片，並且每個圖片 都提供標準化的格式和命名規則，方便比較不同演算法的性能。

---

![圖片：figure-52-34.jpg](images/figure-52-34.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體概述:**

這張標題為「圖 4.1 每個資料庫指紋圖片範例」的圖片展示了FVC2004資料集中四個不同資料庫（DB1至DB4）中的指紋圖像樣本。這些圖像用於研究和比較不同的指紋識別演算法性能。

**詳細分析:**

*   **資料集背景：** 前文說明FVC2004資料集具有多樣性、真實性和標準化等特點，包含來自不同掃描儀類型和品質的指紋圖像。
*   **四個資料庫：**
    *   **DB1:** 使用「V300」光學感測器，解析度為640x480，圖片尺寸為500dpi。圖中顯示的DB1樣本是清晰、對比度較高的指紋圖像，背景乾淨。
    *   **DB2:** 使用「U.are.U 4000」光學感測器，解析度為328x364，圖片尺寸為500dpi。圖中顯示的DB2樣本相對DB1來說，指紋線條細節略顯模糊，背景也稍有雜訊。
    *   **DB3:** 使用熱掃描感測器，解析度為300x480，圖片尺寸為512dpi。圖中顯示的DB3樣本呈現出與前兩個資料庫不同的紋理特徵，可能是由於熱掃描技術所致，線條較粗糙，對比度也相對較低。
    *   **DB4:** 包含合成指紋圖像，解析度為288x384，圖片尺寸約500dpi。圖中顯示的DB4樣本明顯不同於前三個資料庫，呈現出更不規則、雜訊更多的圖像特徵，這是因為它是人工生成的合成數據。
*   **志願者和數量：** 前文提到每個資料庫包含10位指紋志願者（編號101~110），每位志願者提供每隻手指8個指紋印，總共80個指紋圖片。
*   **標準化格式：** 資料集中的所有圖像都採用標準化的格式和命名規則，方便不同演算法的性能比較。

**圖片所表達的核心內容:**

這張圖片旨在展示FVC2004資料集中四種不同類型指紋圖像樣本的外觀差異，突顯了資料集的真實性和多樣性。通過比較DB1、DB2、DB3（真實指紋）和DB4（合成指紋），可以了解不同掃描儀技術和數據生成方式對指紋圖像品質的影響，以及這些差異可能對指紋識別演算法性能造成的挑戰。

總而言之，這張圖片是FVC2004資料集的重要組成部分，它為研究人員提供了直觀的視覺參考，幫助他們更好地理解資料集的特點和應用範圍。

---

圖 4.1 每個資料庫指紋圖片範例

## 4.3 基於 LLM 的 Grafcet 框架生成方法：實驗與應用分析

本節探討大語言模型(LLM)輔助生成 Grafcet action 的實驗過程及結果，特 別是用於生成指紋特徵比對的架構。隨著人工智能技術的發展，LLM 的自動程 式碼生成能力已被廣泛研究與應用[64]。LLM 擁有學習大量程式碼數據的能力， 能夠根據不同的需求生成高效、正確且符合語法規則的程式碼[65]。在本研究中， 測試 LLM 自動生成程式碼是否能夠達到與人工編寫程式碼相同的結果，並分析 其在實驗中的準確性、效率和應用可行性．

## 4.3.1 LLM 模型

在多種 LLM 中，本研究選擇了 GPT 作為程式碼生成的工具。GPT 基於 其在理解語言邏輯和生成結構化內容方面的優勢。GPT 模型能夠有效理解多步 驟流程的描述，並將其準確轉化為程式碼結構[66]。這一點在 Grafcet 流程的生 成中尤為重要，因為該流程包含大量的條件判斷與狀態轉移需求。GPT 能夠根 據簡明的指令生成符合 Grafcet 規格的 C++程式碼，並支援使用者進行二次編輯 或優化。

## 4.3.2 Grafcet Action 生成流程

為了將指紋比對系統的 Grafcet 流程圖轉換為符合需求的 C 程式碼，本研 究運用 MIAT 方法論設計了一套 Grafcet 的流程，整個生成流程被劃分為輸入格 式定義和生成流程設計兩個部分，以確保程式碼的邏輯準確性及生成過程的高 效性，以下將按照各項設計策略的架構逐步說明。

輸入格式定義此階段主要是為 GPT 提供生成程式碼所需的邏輯規範，確保 模型能精確理解 Grafcet 圖形的流程和各步驟的狀態轉移條件。首先 Grafcet 圖 43

形描述格式根據 Grafcet 圖形設定，將每個步驟的狀態和轉換條件進行結構化描 述，並提供給 GPT 作為參考格式。這樣的描述格式不僅定義了程式碼所需的資 料結構，也使 GPT 能準確掌握圖形中的轉換邏輯。

接著步驟轉換條件描述針對 Grafcet 的各步驟轉換條件進行詳細定義，例如 在「旋轉角度比對」階段設定的閾值及「線段方向比對」的偏差範圍等。這些條 件為 GPT 提供了步驟間狀態切換的依據，使其能在程式碼生成過程中，準確設 定各步驟的狀態判斷。GPT 根據這些描述生成程式碼中的 if-else 判斷條件，以 確保每個步驟的執行符合 Grafcet 圖形的要求，並符合流程的設計邏輯。

生成流程設計是 GPT 生成程式碼的具體步驟，透過前處理、Prompt 對話設 計和結果後處理方法，確保生成結果。在前處理步驟時，GPT 生成程式碼之前， 先對 Grafcet 圖形進行結構分析，將每個步驟的轉換條件與動作需求具體化，並 轉化為清晰的提示詞，讓 GPT 能準確把握圖形邏輯。前處理還包括將每步驟的 狀態切換需求定義為條件式格式，便於 GPT 在程式碼生成時依循這些條件進行 判斷。

第二步驟 Prompt 對話設計，為每個步驟設計特定的 Prompt，並將 Grafcet 的 邏輯結構嵌入對話，使 GPT 能理解每步邏輯的需求和條件。對話設計遵循 if-else 判斷結構的基礎邏輯，讓 GPT 針對每個步驟的判斷條件生成程式碼，從而實現 正確的狀態轉移。

第三步驟結果處理方法，在 GPT 生成程式碼後，會對生成結果進行處理， 檢查程式碼的邏輯準確性與每步需求是否符合 Grafcet 圖形。例如，若發現 GPT 生成的程式碼在某些閾值設定上存在不足，會進一步優化 Prompt 重新生成。此 外，要求 GPT 自動添加註解，詳細說明每個步驟的邏輯目的與條件判斷，進一 步增強程式碼的可讀性與維護性，詳見附錄一。

## 4.3.3 生成結果驗證

在本研究中，為了確保程式碼符合預期邏輯並具備實際功能，設計了兩個驗 證階段，邏輯正確性驗證與功能性驗證。這兩個驗證階段相輔相成，分別對程式 碼的內部邏輯和整體功能進行全面檢查，保證最終系統的運行可靠性。邏輯正確 性驗證側重於程式碼內部邏輯的一致性與準確性。該過程包括兩個主要方面：狀 態轉換檢查與條件判斷驗證。

狀態轉換檢查對程式碼中的每個步驟進行檢查，確保狀態轉換符合 Grafcet 圖的預期設計。具體而言，狀態轉移過程中應符合 Grafcet 中的流程邏輯，從一 個狀態進入下一個狀態時，需要符合其設置的觸發條件。若在某狀態中缺少必要 的轉換或出現無效轉換，將會對此進行記錄並修正，以保證程式碼的邏輯嚴謹性。

條件判斷驗證在每個條件判斷部分，檢查 if-else 結構是否正確地執行對應的 條件邏輯。例如，在指紋旋轉比對的步驟中，確認 GPT 生成的程式碼是否正確 地執行旋轉角度比對並設置適當的閾值條件。每個條件的閾值或範圍應符合系 統設計需求，以避免錯誤判斷或非預期結果。條件判斷驗證確保每一判斷邏輯均 符合系統需求並能正確驅動狀態轉換。實際 Prompt 執行結果如下圖 4.2。

---

![圖片：figure-55-35.jpg](images/figure-55-35.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## Grafcet 流程圖文字描述：狀態轉換檢查與條件判斷驗證

這個 Grafcet 流程圖實現了對程式碼中步驟的狀態轉換進行檢查和條件判斷驗證的功能，確保程式碼邏輯符合預期設計，特別針對指紋旋轉比對的步驟。

**1. 初始步驟 (Step 1)：**

系統從步驟 1 開始，處於待機狀態。此步驟為雙線方塊，表示系統啟動或復位後的起始狀態。步驟 1 的動作是「狀態轉換檢查」。這意味著系統會開始對程式碼中的每個步驟進行狀態轉換的有效性驗證。

**2. 流程演進：**

從步驟 1 出發，存在一個轉移條件連接到步驟 2。如果「狀態轉換檢查」完成且沒有發現任何錯誤，則滿足該轉移條件，系統進入步驟 2。

**3. 步驟 2：**

步驟 2 的動作是「條件判斷驗證」。此步驟負責驗證程式碼中每個條件判斷部分的邏輯正確性，例如指紋旋轉比對的閾值設定是否符合系統設計需求。

**4. 分支結構分析：**

從步驟 2 出發，流程經過一條橫線後連接了兩個分支。根據 Grafcet 規則總綱第 4 條，我們需要判斷這是選擇性分支還是並行分支。觀察圖表結構，可以發現橫線之後的每個分支都有其各自獨立的轉移條件（未在圖片中顯示，但從上下文推斷），因此這是一個**選擇性分支**。

* **分支 A：步驟 3 (無效轉換)**
    如果「條件判斷驗證」過程中檢測到無效轉換，則滿足連接到步驟 3 的轉移條件，系統進入步驟 3。步驟 3 的動作是「記錄並修正」。這表示系統會將發現的無效轉換記錄下來，並嘗試進行修正。
* **分支 B：步驟 4 (有效轉換)**
    如果「條件判斷驗證」過程中沒有檢測到任何錯誤，則滿足連接到步驟 4 的轉移條件，系統進入步驟 4。步驟 4 的動作是「完成」。這表示程式碼的狀態轉換和條件判斷都已成功驗證。

**5. 分支合併：**

從步驟 3 和步驟 4 出發，流程都連接到同一個步驟 1。這意味著無論系統發現無效轉換並進行修正（步驟 3），還是驗證通過（步驟 4），最終都會返回到初始步驟 1 的待機狀態，準備開始下一輪的檢查和驗證。

**6. 循環：**

整個流程形成一個循環：從步驟 1 開始「狀態轉換檢查」，然後進行「條件判斷驗證」（步驟 2），根據驗證結果選擇執行「記錄並修正」（步驟 3）或「完成」（步驟 4），最後返回到初始步驟 1，等待下一輪的程式碼輸入。

**總結：**

這個 Grafcet 圖描述了一個自動化的狀態轉換檢查和條件判斷驗證流程，它能夠檢測程式碼中的錯誤並進行修正，確保程式碼邏輯的嚴謹性。通過循環執行，系統可以持續地對程式碼進行驗證，提高程式碼品質和可靠性。

---

---

![圖片：figure-55-36.jpg](images/figure-55-36.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## Grafcet 流程圖文字描述：指紋旋轉比對驗證系統

這個 Grafcet 流程圖實現了一個指紋旋轉比對驗證系統，用於檢查 GPT 生成的程式碼是否正確執行旋轉角度比對並設置適當的閾值條件。系統通過一系列步驟驗證條件判斷邏輯，確保每一判斷均符合系統需求並能正確驅動狀態轉換。

**1. 初始步驟 (Step 0):**

系統啟動或復位後，進入初始步驟（雙線方塊）。此時，所有標誌變數 `X0`、`X1`、`X2`、`X3`、`XN` 和 `flag` 都被初始化為 0。`image_enhancement_done`、`core_point_processing_done`、`feature_point_extraction_done`、`feature_point_matching_done` 初始化為 -1，表示尚未完成對應的步驟。系統處於待機狀態，等待開始驗證。

**2. Step 1: `wait(X0)`**

當 `X0` 的值發生變化時（例如，從 0 變為非 0 值），Step 1 被致能。此步驟持續執行 `printf("Starter validation starting...\n")`，輸出驗證開始訊息。

**3. Step 2: `wait(X1)`**

當 `X1` 的值發生變化時，Step 2 被致能。此步驟執行 `getmanifest()`，獲取 manifest 文件。

**4. Step 3: `wait(X2)`**

當 `X2` 的值發生變化時，Step 3 被致能。此步驟執行 `grafpost()`，將數據發送給 grafpost。

**5. Step 4: `wait(X3)`**

當 `X3` 的值發生變化時，Step 4 被致能。此步驟執行 `grafpost()`，再次將數據發送給 grafpost。

**6. Step 5: `wait(XN)`**

當 `XN` 的值發生變化時，Step 5 被致能。此步驟執行 `grafpost()`，最後一次將數據發送給 grafpost。

**7. 分支結構：選擇性分支**

在 Step 5 之後，流程經過一條橫線後連接了兩個流程，這是一個**選擇性分支**。系統會根據條件判斷的結果選擇執行其中一個路徑。

* **路徑 A: `flag == 0` (未完成)**
    如果 `flag` 的值等於 0，則系統進入 Step 6。Step 6 執行 `printf("Validation failed.\n")`，輸出驗證失敗訊息。
* **路徑 B: `flag != 0` (已完成)**
    如果 `flag` 的值不等於 0，則系統進入 Step 7。Step 7 執行 `printf("Validation passed.\n")`，輸出驗證通過訊息。

**8. Step 8: `wait(XN)`**

無論選擇哪個路徑（Step 6 或 Step 7），流程都會合併到 Step 8。當 `XN` 的值發生變化時，Step 8 被致能。此步驟執行 `grafpost()`，將最終結果發送給 grafpost。

**9. 循環：返回初始狀態**

在 Step 8 完成後，系統會回到 Step 1 (`wait(X0)`)，等待下一次驗證的開始信號。這個循環持續進行，不斷檢查條件判斷邏輯的正確性。

**總結:**

整個流程圖描述了一個基於標誌變數驅動的指紋旋轉比對驗證系統。系統通過一系列步驟獲取數據、發送數據給 grafpost 進行處理，並根據 `flag` 的值判斷驗證結果。無論驗證成功或失敗，都會將最終結果發送給 grafpost，然後返回初始狀態等待下一次驗證。

---

圖 4.2 (a)輸入 Prompt 產生狀態 0-4 (b)實際產生狀態 0-4 的程式碼

在 GPT 產生狀態 4 之後，接續下 40 的 Prompt，並且產生的程式碼順利融合 進前述狀態 4 子涵式內，如下圖 4.3。

---

![圖片：figure-56-37.jpg](images/figure-56-37.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## Grafcet 流程圖 (40-43) 文字描述：程式碼融合驗證流程

這個 Grafcet 流程圖實現了在 GPT 產生狀態 4 後，將後續的 Prompt 產生的程式碼順利融合到前述狀態 4 子函式內的驗證流程。

**1. 初始步驟 (Step 40)：**

系統從初始步驟 40 開始，此步驟處於致能狀態，表示正在等待 GPT 產生狀態 4 的完成。步驟 40 的動作為「程式碼融合驗證」。

**2. 流程演進至 Step 41：**

當 GPT 產生狀態 4 完成後，滿足了從步驟 40 到步驟 41 的轉移條件（未明確說明具體條件，但可推測是狀態 4 生成完成），系統會進入步驟 41。步驟 41 的動作為「初始化」。

**3. 流程演進至 Step 42：**

從步驟 41 到步驟 42 的轉移條件（未明確說明具體條件，但可推測是初始化完成）滿足後，系統進入步驟 42。步驟 42 的動作為「確認是否成功融合程式碼」。

**4. 分支結構分析：選擇性分支**

從步驟 42 到步驟 43 之間存在一條橫線，且之後連接了單一流程（步驟 43），因此根據 Grafcet 規則總綱第 4 條，可以判斷這是一個**選擇性分支**。系統會根據步驟 42 的確認結果來選擇執行哪一個路徑。

*   **成功融合程式碼的路徑：** 如果步驟 42 確認成功融合了程式碼，則滿足從步驟 42 到步驟 43 的轉移條件（未明確說明具體條件，但可推測是融合成功），系統進入步驟 43。
*   **融合失敗的路徑：**  由於圖中僅有一條分支路徑連接到步驟 43，因此沒有顯示融合失敗的流程。可以推測融合失敗的情況會導致流程返回初始狀態或其他錯誤處理機制（未在圖中展示）。

**5. Step 43：**

步驟 43 的動作為「傳回結果」。此步驟表示驗證流程完成，並將結果（成功或失敗）傳回。

**6. 循環：**

從步驟 43 返回初始步驟 40，可以推測系統會重新開始等待 GPT 產生狀態 4，以進行下一次程式碼融合驗證。這個循環持續執行，直到滿足停止條件（未在圖中展示）。

**總結：**

整個流程圖描述了一個自動化的程式碼融合驗證機制。系統首先等待 GPT 生成狀態 4，然後嘗試將後續的 Prompt 產生的程式碼融合到前述狀態 4 子函式內。如果融合成功，則傳回成功結果；否則，可能返回初始狀態或其他錯誤處理流程。這個流程圖的核心在於驗證程式碼融合的正確性，確保系統能夠穩定運行。

---

圖 4.3 (a)輸入狀態 40-43 的 Prompt (b)實際產生狀態 40-43 的程式碼

功能性驗證在程式碼內部邏輯驗證的基礎上進行，重點在於整體功能是否符 合預期，主要通過整合測試方法來進行驗證。在整合測試中，將各步驟的程式碼 組合在一起，並模擬實際指紋比對的情境輸入，觀察系統在不同輸入情況下的運 行結果。每次測試需檢查系統是否能正確完成各比對階段的狀態轉換並產生準 確的比對結果。若整合測試發現功能性問題如下圖 4.4，則將對 Prompt 和生成的 程式碼進行調整，重新生成直至達到功能性驗證的標準，如圖 4.5。

---

![圖片：figure-57-39.jpg](images/figure-57-39.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## Grafcet 流程圖 (圖 4.4) 文字描述：執行修正 Prompt 的功能驗證流程

這個 Grafcet 流程圖實現了在程式碼內部邏輯驗證後，對指紋比對功能的整體功能進行驗證，並根據測試結果執行修正 Prompt 的流程。

**1. 初始步驟 (Step 415):**

系統從步驟 415 開始，代表著功能性驗證的起始狀態。此時，系統處於「已啟動 415」狀態，等待接收輸入以進行整合測試。步驟 415 的動作是 `WRB 415`，表示初始化相關變數或準備測試環境。

**2. 流程演進 (Step 415 -> Step 416/417):**

從步驟 415 出發，系統會檢查條件 `X418 <- 1 && get_data_430 == 1`。如果這個條件為真，則觸發轉移，進入下一步驟。

**3. 分支結構分析：選擇性分支**

在步驟 415 到 416/417 的連接處存在一個橫線，根據 Grafcet 規則總綱第 4 條的判斷，這是一個**選擇性分支**。因為橫線之後的每個流程（到 416 和 417）都有各自獨立的轉移條件。系統會根據哪個條件首先被滿足來選擇執行對應的路徑。

**4. 分支一 (Step 415 -> Step 416):**

*   如果 `X418 <- 1 && get_data_430 == 1` 為真，則系統進入步驟 416，代表「rotationpoints_ressining Vor_celoulation 415」狀態。
*   步驟 416 的動作是 `DM rotationpoints_ressining Vor_celoulation 415`，表示執行旋轉點重計算相關的邏輯。
*   從步驟 416 出發，系統會檢查條件 `Vor_celoulation 415 <= 1`。如果這個條件為真，則觸發轉移，進入下一步驟 417。

**5. 分支二 (Step 415 -> Step 417):**

*   如果 `X418 <- 1 && get_data_430 == 1` 為真，則系統進入步驟 417，代表「rotation_patnt_colculstion_completed_415」狀態。
*   步驟 417 的動作是 `GF rotation_patnt_colculstion_completed_415`，表示執行旋轉模式計算完成相關的邏輯。
*   從步驟 417 出發，系統會檢查條件 `rotation_patnt_colculstion_completed_415 <= 1`。如果這個條件為真，則觸發轉移，進入下一步驟 418。

**6. Step 418 (未顯示完整流程):**

步驟 418 的具體流程沒有在提供的圖表中完全展示，但可以推斷其後續的邏輯會根據測試結果進行 Prompt 的調整和程式碼重新生成，以達到功能性驗證的標準。

**7. 循環:**

整個流程從步驟 415 開始，通過整合測試模擬實際指紋比對情境，並根據測試結果選擇執行不同的分支路徑（416 或 417）。最終，系統會返回到初始步驟 415，準備下一次的測試迭代。這個循環持續進行，直到功能性驗證達到預期標準。

**總結:**

此 Grafcet 圖表描述了一個基於條件判斷的功能性驗證流程，它通過選擇性分支來處理不同的測試結果，並執行相應的修正操作，以確保指紋比對功能的整體性能和準確性。

---

## 圖 4.4 執行修正 Prompt

---

![圖片：figure-57-40.jpg](images/figure-57-40.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體理解:**

這張圖片展示的是一段程式碼片段以及對該程式碼修正後狀態的描述。根據上下文，可以判斷這段程式碼是經過修改後的版本，目的是修正 415 至 416/417 的判斷邏輯。圖片標題為「執行修正 Prompt」，暗示這段程式碼是透過某種提示（Prompt）進行了修正。

**詳細分析:**

*   **程式碼片段：**
    ```
    X418 = 0;
    X418 = 1;
    rotation_point_exclusion_completed_418 = 0;
    return;
    }
    ```
    這段程式碼看起來像是初始化了一些變數，並設定了 `rotation_point_exclusion_completed_418` 為 0，最後使用 `return` 語句結束函數。雖然程式碼本身很簡短，但上下文表明它代表了修正後的狀態。

*   **修復的條件邏輯：**
    圖片下方列出了「修正後的條件邏輯」，詳細描述了在不同狀態下的行為：
    1.  **狀態 415:**
        *   如果 `rotation_points_remaining_for_calculation_415` 等於 1，則進入狀態 416。
        *   如果 `rotation_points_calculation_completed_415` 等於 1，則進入狀態 417。
    2.  **狀態 416:**
        *   處理下一個段落點後，返回到狀態 410。
    3.  **狀態 417:**
        *   確定旋轉角度後，進入狀態 418。

**前後文的關聯：**

*   「更新後的程式碼 (修正 415 至 416/417 的判斷 )」說明這段程式碼是為了改善先前版本中在 415 到 416 或 417 狀態之間的判斷錯誤。
*   圖片標題「執行修正 Prompt」暗示了修改的過程可能使用了某種自動化工具或技術，例如大型語言模型（LLM）接收一個提示後進行程式碼調整。
*   圖 4.5 「產生修改後的程式碼」表明這張圖片展示的是經過修正後的最終版本。

**總結：**

這張圖片呈現了透過某種方式（Prompt）修正過後的程式碼片段，以及對該修正所涉及的條件邏輯的詳細說明。修正的核心在於改善 415 至 416/417 的判斷流程，並定義了不同狀態下的行為。

---

圖 4.5 產生修改後的程式碼

透過以上步驟將離散事件的系統架構，結合 GPT 產生的程式碼，完成高階 合成的程式碼，架構流程圖如圖 4.6。

---

![圖片：figure-58-41.jpg](images/figure-58-41.jpg)

**🖼️ VLM 圖片解釋 (類型: IDEF0)：**

> 好的，我將根據您提供的Prompt和圖片內容，分析並描述該系統架構圖。

**層級關係：** 此圖表為父圖 A0 中，模組 A2 的詳細分解（根據上下文推斷）。

**子模組分析：**

*   **模組編號 1: 可重構指紋特徵比對軟體**
    *   **輸入 (Input):**
        *   系統需求：(外部來源)
        *   高階合成：(外部來源)
        *   LLM輔助成：(外部來源)
        *   IDEF0 階層式架組：(外部來源)
        *   Grafcet 離散事件件建模：(外部來源)
    *   **輸出 (Output):**
        *   系統統一：(流至 外部)

**總結:**

此圖表展示了「可重構指紋特徵比對軟體」模組的詳細設計。該模組接收來自多個來源的輸入，包括系統需求、高階合成結果、LLM輔助生成資訊、IDEF0 架構模型以及Grafcet 離散事件建模資料。處理這些輸入後，輸出為系統統一的成果。

**補充說明:**

*   根據上下文，圖4.6展示的是架構流程圖，而此圖表是針對「可重構指紋特徵比對軟體」模組的更詳細分解。
*   上下文中提到其他系統架構相關程式碼詳見附錄二，因此可以推斷該圖表只是整個系統的一個組成部分。
*   忽略了頂部和底部的箭頭，專注於左側輸入和右側輸出，符合Prompt的要求。

希望這個分析對您有所幫助！

---

圖 4.6 架構流程圖簡易

下圖 4.7 內容展示了指紋比對模組軟體中 0 至 410 狀態的高階軟體合成程 式碼及其狀態轉移結果，其他系統架構相關的程式碼詳見 附錄二，其中包含高 階軟體合成的完整實現。完成高階合成後，將進一步進行指紋比對軟體的驗證

工作，以確保各狀態的運行邏輯與功能的完善性。

---

![圖片：figure-58-42.jpg](images/figure-58-42.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> 好的，我將根據提供的 Grafcet 規則總綱和圖片資訊，生成一份關於指紋比對模組 0 至 410 狀態高階軟體合成的完整文字描述。

---

**指紋比對模組 0 至 410 狀態高階軟體合成流程描述**

這個 Grafcet 流程圖實現了指紋特徵提取和初步分析的功能，從圖像增強到計算脊線密度，為後續的比對驗證提供基礎數據。

**初始步驟：State 0 - Initializing (Initializing)**

系統啟動時，進入 State 0，執行初始化操作。這是系統的待機狀態，準備開始指紋比對流程。

**流程演進：**

1.  **State 1 - Performing image enhancement (Performing image enhancement)**: 初始化完成後，系統進入 State 1，執行圖像增強處理。
2.  **State 2 - Core point processing (Core point processing)**: 完成圖像增強後，系統進入 State 2，進行核心點的處理。
3.  **State 3 - Feature point extraction (Feature point extraction)**: 核心點處理完成後，系統進入 State 3，提取特徵點。
4.  **State 4 - Entering sub-process (Entering sub-process)**: 特徵點提取完成後，系統進入 State 4，準備進入子流程。

5. **State 40 - Reading sample/test feature points (Reading sample/test feature points)**：進入子流程後，系統進入 State 40，讀取樣本或測試特徵點。
6.  **State 4 - Entering sub-process (Entering sub-process)**: 讀取特徵點完成後，再次進入 State 4，準備執行下一個子流程。

7. **State 41 - Performing rotation exclusion (Performing rotation exclusion)**：系統進入 State 41，執行旋轉排除處理，X411 = 0, X412 = 0, X413 = 0, X414 = 0, X415 = 0, X416 = 0, X417 = 0, X418 = 0。
8. **State 410 - Getting data (Getting data)**：旋轉排除處理完成後，系統進入 State 410，獲取數據，X411 = 0, X412 = 0, X413 = 0, X414 = 0, X415 = 0, X416 = 0, X417 = 0, X418 = 0。
9. **State 4 - Entering sub-process (Entering sub-process)**：獲取數據完成後，再次進入 State 4，準備執行下一個子流程。

10. **State 41 - Performing rotation exclusion (Performing rotation exclusion)**：系統再次進入 State 41，執行旋轉排除處理，X411 = 0, X412 = 0, X413 = 0, X414 = 0, X415 = 0, X416 = 0, X417 = 0, X418 = 0。
11. **State 411 - Calculating line similarity (Calculating line similarity)**：旋轉排除處理完成後，系統進入 State 411，計算線條相似度。
12. **State 4 - Entering sub-process (Entering sub-process)**：計算線條相似度完成後，再次進入 State 4，準備執行下一個子流程。

13. **State 41 - Performing rotation exclusion (Performing rotation exclusion)**：系統再次進入 State 41，執行旋轉排除處理，X411 = 0, X412 = 0, X413 = 0, X414 = 0, X415 = 0, X416 = 0, X417 = 0, X418 = 0。
14. **State 412 - Calculating bifurcation point (Calculating bifurcation point)**：旋轉排除處理完成後，系統進入 State 412，計算分叉點。
15. **State 4 - Entering sub-process (Entering sub-process)**：計算分叉點完成後，再次進入 State 4，準備執行下一個子流程。

16. **State 41 - Performing rotation exclusion (Performing rotation exclusion)**：系統再次進入 State 41，執行旋轉排除處理，X411 = 0,

---

圖 4.7 指紋比對模組 0 至 410 狀態的高階軟體合成狀態轉移結果

## 4.4 可重構指紋特徵比對驗證

實驗目的在於驗證指紋特徵比對架構的準確性和可重構性，因此本研究採 用了 Minutia 比對與 FLANN (Fast Library for Approximate Nearest Neighbors)比對 技術，通過將擷取的特徵點輸入不同的比對演算法中，來驗證系統在不同比對方 法下的差異表現。

## 4.4.1 指紋特徵點擷取

依據 FVC2004 數據庫所產生的特徵點集，這些特徵點集內容包含Ｘ座標、 Ｙ座標、方向與特徵點種類和曲率，作為比對的基礎數據。實驗開始時，從指紋 比對程式介面中如圖 4.8，選取兩組特徵點作為比對輸入資料如圖 4.9 所示，分 別定義為測試特徵集(Test template)和樣本特徵集(Sample template)。

圖 4.8 指紋比對系統操作介面

圖 4.9 選取樣本特徵集(DB1_102_2)與測試特徵集(DB1_102_5)

這些資料集輸入至比對系統中進行讀取和比對。當系統成功讀取特徵點後，

對應的指紋特徵點會顯示在界面上如圖 4.10，便於用戶觀察和驗證讀取是否完

## 整，並為後續的指紋比對實驗提供參考。

## 圖 4.10 確認系統成功正確讀取特徵點數據

## 4.4.2 Minutia 比對實驗

本論文旨在提出了一種可重構指紋特徵點比對架構，以提高指紋比對的準 確性和效率。為驗證此框架的可行性，在實驗中使用 Minutia 演算法比對，因為 Minutia 比對為目前最廣泛的[67]。

Minutia 實驗結果如下圖 4.11，在系統中勾選 Minutia Matching 功能後，選 擇樣本特徵集 DB1_102_2 與測試特徵集 DB1_102_5 進行比對，系統隨即顯示 比對結果，相似度分數為 154。根據 Minutia 演算法的說明，相似度分數介於 30 到 1000 之間，皆表示兩者存在部分特徵點相似，可判斷為同一隻手指。

---

![圖片：figure-61-46.jpg](images/figure-61-46.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我將根據您提供的圖片和前後文資訊，進行詳細的分析與解讀：

**整體概述:**

圖4.11展示的是一個指紋比對實驗成功的結果截圖，該實驗使用了Minutia演算法，旨在驗證論文中提出的可重構指紋特徵點比對架構的可行性。

**圖片內容細節分析:**

*   **視窗標題：** “MIAT-Development of Reconfigurable Minutia Matching Software - Verification” 表明這是由MIAT開發的可重構Minutia比對軟體的驗證介面。
*   **兩個指紋圖形：** 截圖中顯示了兩個指紋圖像，分別標記為“DB1\_102\_2”和“DB1\_102\_5”。這些圖像上覆蓋著綠色的線條，代表提取出的指紋特徵點（Minutia points）。
*   **勾選框：** “Minutia Matching” 複選框被勾選，表示實驗中啟用了Minutia比對功能。
*   **相似度分數：** 在圖片下方顯示的數值列表是比對結果，其中“154”為計算出的相似度分數。根據上下文描述，該分數介於30到1000之間，表明兩組指紋存在部分特徵點相似。
*   **比對結果訊息：** 圖片底部顯示 “Matching features from DB1\_102\_2 and DB1\_102\_5” 以及 “File complete: 2 files processed”，表示成功完成了DB1\_102\_2和DB1\_102\_5兩個檔案的比對，且處理了2個檔案。
*   **FLANN Matching：** 截圖中可以看到“FLANN Matching”的複選框未勾選，暗示論文可能也研究了其他比對演算法（例如FLANN），但本次實驗專注於Minutia比對。

**結合上下文的解讀:**

*   **驗證可重構架構：** 圖片是為了證明論文提出的可重構指紋特徵點比對架構在實際應用中有效，通過使用Minutia演算法進行比對，並得到相似度分數，來佐證架構的可行性。
*   **Minutia演算法的選擇：** 上下文提到Minutia比對是目前最廣泛使用的指紋比對方法之一，因此選擇該演算法作為實驗基礎具有代表性。
*   **成功比對的判斷標準：** 相似度分數為154，雖然沒有具體說明閾值，但根據上下文描述，只要分數介於30到1000之間，就可判斷為同一隻手指，因此本次實驗結果表明DB1\_102\_2和DB1\_102\_5屬於同一指紋。
*   **圖4.11的標題：** “Minutia 比對實驗成功結果” 直接點明了圖片所展示的是一次成功的比對案例。

**總結:**

這張圖片是論文中驗證可重構指紋特徵點比對架構可行性的重要證據，通過Minutia演算法的比對，成功識別出兩組指紋的相似性，並提供了具體的相似度分數作為支持。 圖片清晰地展示了比對過程和結果，為讀者理解論文的研究方法和成果提供了直觀的參考。

---

## 圖 4.11 Minutia 比對實驗成功結果

選擇樣本特徵集 DB1_101_1 與測試特徵集 DB1_101_6 進行比對時，系統 顯示相似度分數為 0，表示兩者之間沒有任何相同的特徵點，據此可判定為不同 的手指，結果如下圖 4.12。

---

![圖片：figure-62-47.jpg](images/figure-62-47.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體解讀：**

這張圖片展示的是一個指紋比對實驗的失敗案例。實驗使用名為“Reconfigurable Minutia Matching Software”的軟體進行驗證，目的是比較兩個指紋樣本（DB1_101_1 和 DB1_101_6）之間的相似度。結果顯示，系統判定這兩個指紋**不匹配**。

**詳細分析：**

1. **圖片內容：**
   *  畫面分為左右兩部分，分別展示了兩個指紋圖像（DB1_101_1 和 DB1_101_6）。
   *  在每個指紋圖像上，都有綠色的線段標記。這些線段代表著指紋的“特徵線段”（Minutia），是比對演算法關注的核心要素。
   *  畫面底部顯示了軟體的運行資訊，包括：
      *  檔案路徑、解析度等技術參數。
      *  “Feature Count: 37”表示在DB1_101_1指紋中檢測到37個特徵點。
      *  最重要的是，紅框標註的 “Minutiae Match failed. Similarity Score: 0”，明確指出比對失敗，相似度分數為0。

2. **前後文關聯：**
   *  **上下文文字（圖片前）：** 強調了選擇樣本特徵集 DB1_101_1 與測試特徵集 DB1_101_6 進行比對時，系統顯示相似度分數為 0。這直接解釋了圖片的結果：兩者之間沒有任何相同的特徵點，因此判定為不同的手指。
   *  **上下文文字（圖片後）：** 描述了比對演算法的基本流程：擷取測試樣本和樣板中的特徵線段，計算參數，並通過“Pair’s similarity”判斷相似度。這說明了系統是如何評估指紋相似度的，以及為什麼會得出0分的分數——因為兩個指紋的特徵線段之間沒有匹配的部分。

**結論：**

圖 4.12 是實驗結果的可視化呈現，清晰地展示了兩個指紋圖像及其比對失敗的情況。通過綠色線段標記和相似度分數為0的結果，驗證了演算法能夠正確識別出不同的手指。這張圖片主要用於說明在某些情況下，指紋比對可能會因為缺乏共同特徵而失敗。

---

圖 4.12 Minutia 比對實驗失敗結果

在比對的演算法中，會比對兩個指紋的樣板及回傳兩指紋的相似度 (Similarity)。比對過程首先擷取測試樣本與樣本樣板中的特徵線段，並對其進行 初步的參數計算。接著，透過計算特徵線段的相似度(Pair’s similarity)，判斷兩線

段是否進一步進入門檻篩選步驟。相似度的值是基於線段長度(D)、角度 (α1 和 α2)等參數加權平均後得出，用以評估特徵線段的比對程度，參數如下圖 4.13 說 明。

---

![圖片：figure-63-48.jpg](images/figure-63-48.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來分析這張圖片及其前後文，並提供詳細的解釋：

**總體概述:**

這張圖（圖4.13）展示的是用於評估兩個線段相似度的參數示意圖。這些參數將被用來計算特徵線段的比對程度，進而決定是否進入更細緻的門檻篩選步驟。圖片配合前後文描述，可以理解為演算法在進行圖像比對時，如何量化兩個線段之間的差異，並以此作為判斷相似度的依據。

**參數詳細解釋:**

*   **D (線段長度):**  圖中用直線表示的線段本身，其長度是影響相似度的一個重要因素。線段長度越接近，比對程度越高。
*   **α1 和 α2 (角度):** 這兩個角度分別代表線段端點與水平軸（或參考軸）之間的夾角。它們描述了線段的方向信息。
    *   `α1`: 線段起始端點(E1)的角度，表示線段的開始方向。
    *   `α2`: 線段終止端點(E2)的角度，表示線段的結束方向。
*   **E1 和 E2 (端點位置):**  分別代表線段的兩個端點的位置。在平移處理階段，演算法會以這些端點作為核心進行比對，排除不合理或相似度過低的樣板。

**上下文關聯:**

*   **前文：** 說明了相似度的計算依賴於線段長度(D)、角度 (α1 和 α2)等參數的加權平均。這張圖就是為了解釋這些參數的具體含義。
*   **後文：**  強調了旋轉處理和平移處理在比對中的作用，以及這些參數（特徵方向、角度、端點位置）如何影響旋轉和平移的過程。

    *   **旋轉處理:** 演算法會根據測試樣板的特徵方向(α)進行旋轉，目的是找到最佳旋轉角度，使兩個樣板的相似度最大化。
    *   **平移處理:**  以端點位置(E1 和 E2)為核心，排除不合理的樣板。

**總結：**

這張圖是圖像比對演算法中一個關鍵步驟的參數說明。通過量化線段長度、方向和端點位置等信息，演算法可以更精確地評估兩個線段之間的相似度，並進行旋轉和平移處理，最終實現圖像的比對和識別。 這些參數共同構成了相似度計算的基礎，是判斷兩個圖像特徵是否匹配的重要依據。

---

圖 4.13 線段與線段參數

在旋轉與平移處理階段，演算法會根據測試樣板的特徵方向進行適當的旋 轉與位移。旋轉處理的目的是找出最佳旋轉角度，使測試樣板與樣本樣板的相似 度最大化。特徵線段的方向(α)以及角度(α1 和 α2)是旋轉處理的重要依據；平移 處理則以特徵線段的端點位置(E1 和 E2)為核心，排除不合理或相似度過低的樣 板。

最終，比對通過旋轉與平移處理的特徵線段後，演算法將統合所有有效線 段的相似度值，計算出整體樣板的最終相似度(Similarity)，實驗紀錄 60 組如下

表 4.3 Minutia 比對實驗結果紀錄

**📊 表格內容：**

<table><thead><tr><th>Group</th><th>Inputl</th><th>Input2</th><th>Minutia Similarity</th><th>Minutia Time</th></tr></thead><tbody><tr><td>1</td><td>DB1_102_1</td><td>| DB1_102_5</td><td>169</td><td>547ms</td></tr><tr><td>2</td><td>DB1_101_1</td><td>| DB1_101_6</td><td>0</td><td>281ms</td></tr><tr><td>3</td><td>DB4_108_7</td><td>| DB4_108_8</td><td>0</td><td>625ms</td></tr><tr><td>4</td><td>DB1_101_6</td><td>| DB1_101_7</td><td>113</td><td>360ms</td></tr></tbody></table>

**📊 表格內容：**

<table><thead><tr><th>5</th><th>DB1_101_1</th><th>| DB1_101_2</th><th>0</th><th>250ms</th></tr></thead><tbody><tr><td>6</td><td>DB4_103_7</td><td>| DB4_103_8</td><td>61</td><td>672ms</td></tr><tr><td>57</td><td>DB2_107_7</td><td>| DB2_107_8</td><td>302</td><td>766ms</td></tr><tr><td>58</td><td>DB3_103_5</td><td>| DB3_103_6</td><td>0</td><td>1s485ms</td></tr><tr><td>59</td><td>DB2_108_5</td><td>| DB2_108_6</td><td>0</td><td>985ms</td></tr><tr><td>60</td><td>DB2_108_6</td><td>| DB2_108_7</td><td>0</td><td>1s16ms</td></tr></tbody></table>

## 4.4.3 FLANN 比對實驗

基於 FLANN 演算法特性與優點，本研究將其作為測試可重構指紋比對架構 更換之模組。FLANN 指紋特徵點比對系統實驗步驟，首先，演算法的目的是在 兩組指紋特徵點之間找到相鄰的對應點，並衡量相似性[68]。特徵點包括位置 (x, y)和方向(Direction)。

在實驗中，準備兩組指紋特徵點集為 DB1_102_2 與 DB1_102_5，並在系統 中勾選 FLANN Matching 功能。後端會將資料分別標記為 𝐹1(DB1_102_2) 和 𝐹2(DB1_102_5)，對於每個在𝐹1中的特徵點𝑓1𝑖，找到𝐹2中距離最近的特徵點 𝑓2𝑗。為此，需設定 FLANN 比對器的參數，包括算法和搜尋精度。本次實驗選 擇 KD 索引樹(FLANN_INDEX_KDTREE)進行最近鄰查找，並設置維度樹的數 量參數(Trees=5)以及遞迴索引樹的檢查次數參數(Checks=50)，以平衡查找速度 與準確度。

接著執行 FLANN 比對程式，根據設定進行 KNN (K-Nearest Neighbors)比 對，將每個特徵點與目標影像中最接近的兩個特徵點進行比對。接下來進行比對 結果的篩選，參考 Lowe 實驗[54]的測試閥值設定為 0.7，過濾掉距離過大的比對 結果，保留高品質的特徵點對。最終的相似性計算是依據所有最近距離的平均值 來進行計算，並得到相似值 0.3604，實驗結果如圖 4.14 所示。

---

![圖片：figure-65-49.jpg](images/figure-65-49.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體解讀：**

這張圖片展示的是一個指紋比對軟體的介面截圖，具體來說是使用 FLANN (Fast Library for Approximate Nearest Neighbors) 演算法進行指紋特徵點比對的成功案例。根據上下文，這個實驗旨在驗證軟體的比對能力，並得到了一個相似度評估結果。

**詳細分析：**

1. **介面組成：**
   *  圖片頂部顯示了兩個視窗，分別標記為 `DB1_102_2` 和 `DB1_102_5`。這代表軟體正在比較兩枚指紋圖像（可能來自不同的資料庫或同一人的不同採集樣本）。
   *  每個視窗內都顯示了指紋的特徵點，這些特徵點以紅色小點的形式標示出來。這些點代表指紋中的細節結構，例如嵴線終止點和分叉點（Minutiae），是指紋比對的核心依據。
   *  介面底部有兩個選項：`FLANN Matching` 和 `Minutiae Matching`。這表明軟體支援多種比對演算法，目前正使用 FLANN 演算法。

2. **FLANN 比對過程（根據上下文）：**
   *  **KNN 比對:** 軟體首先執行 FLANN 比對程式，利用 KNN (K-Nearest Neighbors) 演算法，將每個指紋的特徵點與另一個指紋中最接近的兩個特徵點進行比對。
   *  **結果篩選:**  接著，使用設定好的閥值（0.7）過濾掉距離過大的比對結果，保留高品質的特徵點對。這可以排除錯誤的比對，提高準確性。
   *  **相似度計算:** 最終，根據所有最近距離的平均值來計算相似度。

3. **實驗結果（圖片中的資訊）：**
   *  `Getting Scores for DB1_102_2 and DB1_102_5`: 表明軟體正在計算 `DB1_102_2` 和 `DB1_102_5` 這兩枚指紋的相似度。
   *  `Final Similarity Score: 0.36048511627906974`:  這是實驗得到的最終相似度評估值，為 0.36048511627906974。這個數值代表兩枚指紋的相似程度。
   *  `Time: 7ms`: 表明比對過程耗時 7 毫秒，顯示了演算法的效率。
   *  `File list complete: 2 files processed`: 表示軟體已經處理完兩個檔案。

4. **上下文確認：**
    * 上下文明確指出這張圖片是「FLANN 比對實驗成功結果」，說明這個相似度評估值被認為是可以接受的，代表比對過程取得了預期的效果。

**總結：**

這張圖片展示了使用 FLANN 演算法進行指紋比對軟體的介面截圖，並呈現了一個成功的比對案例。通過 KNN 比對、結果篩選和相似度計算，軟體得到了兩枚指紋圖像的相似度評估值為 0.36048511627906974。這個結果表明該軟體的 FLANN 比對功能可以有效地識別指紋特徵點並進行比對。

---

圖 4.14 FLANN 比對實驗成功結果

然而，在選擇第二組實驗特徵點集 DB1_101_1 和 DB1_101_6 時，系統得 出的相似值為 0，這表示兩組數據間無鄰近的特徵點，因此無法比對成功，實驗 結果如圖 4.15 所示。

---

![圖片：figure-66-50.jpg](images/figure-66-50.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體解讀：**

這張圖展示的是一個指紋比對實驗的失敗案例。實驗使用了 FLANN (Fast Library for Approximate Nearest Neighbors) 算法進行指紋特徵點的比對，但結果顯示比對失敗。

**詳細分析：**

1. **圖片內容:**
   *  圖片呈現了兩個指紋圖像，分別標記為 "DB1_101_1" 和 "DB1_101_6"。在每個指紋圖像上，綠色的點代表提取出的特徵點（Minutiae）。
   *  界面下方有兩個複選框："FLANN Matching" 和 "Minutiae Matching"，其中 "FLANN Matching" 被勾選，表示正在使用 FLANN 算法進行比對。
   *  圖片底部有一個文本區域顯示了實驗的相關信息：
      *  `Size: 300x300 Resolution: 250 dpi`: 指紋圖像的大小和分辨率。
      *  `Features Counts: 37`: 表示提取出的特徵點數量為 37 個。
      *  `FLANN result`: 表明這是 FLANN 比對的結果。
      *  `Getting features for DB1_101_1 and DB1_101_6`: 指出正在提取兩個指紋圖像的特徵點。
      *  `Final Similarity Score: 0`: **關鍵信息！**最終相似度分數為 0，這意味著 FLANN 算法認為這兩組指紋數據之間沒有足夠的相似性。
      *  `Time: 781 ms`: 比對所花費的時間。

2. **前後文關聯:**
   *  **上下文文字 (圖片前):** 明確指出在選擇特徵點集 DB1_101_1 和 DB1_101_6 時，系統得到的相似值為 0。這解釋了圖中 "Final Similarity Score: 0" 的原因：由於兩組數據間沒有鄰近的特徵點，因此無法成功比對。
   *  **上下文文字 (圖片後):** 將該圖標記為 "FLANN 比對實驗失敗結果"，進一步確認了圖片所展示的是一個比對失敗的案例。

**結論：**

這張圖片清晰地呈現了一個使用 FLANN 算法進行指紋比對的失敗案例。由於選擇的特徵點集 DB1_101_1 和 DB1_101_6 在特徵點分布上差異過大，導致 FLANN 算法無法找到足夠的匹配點，最終相似度分數為 0，比對宣告失敗。圖片中的界面信息和上下文文字相互印證，完整地說明了實驗結果。

---

圖 4.15 FLANN 比對實驗失敗結果

此外，實驗中共隨機選擇 60 組數據進行比對，詳細實驗紀錄如表 4.4 所

表 4.4 FLANN Matching 實驗結果紀錄

**📊 表格內容：**

<table><thead><tr><th>Group</th><th>Inputl</th><th>Input2</th><th>FLANN Similarity</th><th>| FLANN Time</th></tr></thead><tbody><tr><td>1</td><td>DB1_102_1</td><td>| DB1_102_5</td><td>0.348837209</td><td>995ms</td></tr><tr><td>2</td><td>DB1_101_1</td><td>| DB1_101_6</td><td>0</td><td>770ms</td></tr><tr><td>3</td><td>DB4_108_7</td><td>| DB4_108_8</td><td>0</td><td>1s103ms</td></tr><tr><td>4</td><td>DB1_101_6</td><td>| DB1_101_7</td><td>0</td><td>1s43ms</td></tr><tr><td>5</td><td>DB1_101_1</td><td>| DB1_101_2</td><td>0</td><td>1s128ms</td></tr><tr><td>6</td><td>DB4_103_7</td><td>| DB4_103_8</td><td>0</td><td>1s87ms</td></tr><tr><td>57</td><td>DB2_107_7</td><td>| DB2_107_8</td><td>0.3888888</td><td>1s53ms</td></tr><tr><td>58</td><td>DB3_103_5</td><td>| DB3_103_6</td><td>0.482758621</td><td>1s21ms</td></tr><tr><td>59</td><td>DB2_108_5</td><td>| DB2_108_6</td><td>0</td><td>1s11ms</td></tr><tr><td>60</td><td>DB2_108_ 6|</td><td>DB2_108_7</td><td>0.396039604</td><td>1s49ms</td></tr></tbody></table>

## 4.5 結果比較

本實驗採用了 Minutia Matching 和 FLANN Matching 兩種指紋比對技術，隨 機選擇 60 組共 120 個指紋特徵點集進行比對驗證。每組指紋樣本包含不同的特 徵點數量和指紋特徵點分布，透過這些測試，從比對準確性、性能表現兩個評估 指標來評估整體系統的效果。

比對準確性為本實驗中的核心指標，用於衡量 Minutia Matching 與 FLANN Matching 的結果準確度。在 60 組指紋測試中，兩者的準確率和錯誤率皆被記錄

與分析。本研究圍繞「可重構指紋特徵比對」的主題，旨在驗證設計架構的靈活 性與適應性。實驗採用了基於指紋特徵點的 Minutia 比對與 FLANN 比對，兩者 在理論基礎與實現方法上存在顯著差異。Minutia 比對依賴細節點(如分叉點與終 止點)的位置和方向進行比對，適用於細節完整的高質量指紋圖像。而 FLANN 比 對基於特徵點的全局搜索，對圖像模糊或細節缺失具有一定的容忍度。這種方法 學差異使其成為檢驗架構可重構性的理想組合。

實驗將數據分為三組：第一組是 Minutia 和 FLANN 同時比對成功或失敗； 第二組是 Minutia 比對成功而 FLANN 比對失敗；第三組則是 FLANN 比對成功 而 Minutia 比對失敗。實驗結果顯示如下圖 4.16，Minutia 和 FLANN 的比對結果 一致性最高(61.7%)，即兩者同時比對成功或均比對失敗。這表明在指紋圖像有 相同特徵點條件下，兩種方法能夠共同提供準確的比對結果，架構能同時支持兩 種比對模式並保持結果的一致性與穩定性。此外，26.7%的數據中僅 Minutia 比 對成功，反映出其對局部特徵點的敏感性強於 FLANN，適合局部細節完整但全 局特徵不足的指紋圖像。而僅有 11.7% 的數據顯示FLANN比對成功但 Minutia 比對失敗。

---

![圖片：figure-68-51.jpg](images/figure-68-51.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容。

**總結：** 這張圓餅圖（標題為“Group Distribution”）呈現了指紋比對實驗結果的統計數據，用以驗證「可重構指紋特徵比對」架構的靈活性和適應性。它比較了兩種比對方法——Minutia 比對和 FLANN 比對——在不同情況下的表現。

**詳細分析：**

1.  **實驗設計與分組：**
    *   研究將指紋數據分為三組，基於 Minutia 和 FLANN 兩種比對方法的成功或失敗狀態進行分類：
        *   **Group 1 (藍色)：** Minutia 比對成功 *且* FLANN 比對成功/均失敗（佔 61.7%，共37組）。
        *   **Group 2 (淺綠色)：** Minutia 比對成功 *但* FLANN 比對失敗（佔 26.7%，共16組）。
        *   **Group 3 (粉紅色)：** FLANN 比對成功 *但* Minutia 比對失敗（佔 11.7%，共7組）。

2.  **圓餅圖的呈現：**
    *   藍色扇形代表 Group 1，占比最大(61.7%)。
    *   淺綠色扇形代表 Group 2，占比第二大(26.7%)。
    *   粉紅色扇形代表 Group 3，占比最小(11.7%)。

3.  **實驗結果解讀：**
    *   **一致性最高 (61.7%):**  Group 1 的高比例表明在大多數情況下，Minutia 和 FLANN 比對的結果是一致的——要么都成功比對，要么都失敗。這支持了研究提出的架構具有良好的穩定性和一致性，能夠同時支持兩種比對模式。
    *   **Minutia 的優勢 (26.7%):** Group 2 的占比顯示，在約四分之一的數據中，只有 Minutia 比對成功。這說明 Minutia 比對對於局部特徵點更敏感，適合處理局部細節完整但全局特徵不足的指紋圖像。
    *   **FLANN 的優勢 (11.7%):** Group 3 的占比相對較小，表明只有 FLANN 比對成功的情況較少。這說明 FLANN 比對在某些情況下能夠容忍圖像模糊或細節缺失，適用於質量較差的指紋圖像。

4.  **總體結論：**
    *   實驗結果驗證了該「可重構指紋特徵比對」架構的靈活性和適應性。通過結合 Minutia 和 FLANN 兩種方法，可以提高指紋比對的準確性和魯棒性，並在不同質量圖像下都能夠提供可靠的比對結果。

**圖片標題“圖 4.16 指紋比對相似度統計圖”也與上述分析相符，表明這張圖是為了展示指紋比對方法之間相似度的分佈情況。**

希望這個詳細的解釋能夠幫助您理解這張圖片及其所表達的內容！

---

圖 4.16 指紋比對相似度統計圖

針對不同比對模組的性能表現，本實驗比較了每種方法在運行速度差異，在 運算時間上，Minutia Matching 的性能優勢更為明顯。然而，FLANN 和 Minutia 兩種比對方法的處理時間比較中進一步分析，根據下圖 4.17 時間數據的統計圖 顯示，整體而言，Minutia 比對的執行時間相較於 FLANN 展現了一定的優勢。 Minutia 方法在指紋特徵點比對中通常只針對較小的數據集進行比對，而 FLANN 主要基於快速最近鄰搜尋，因此對於高維特徵數據的處理效率會因數據量增加

---

![圖片：figure-69-52.jpg](images/figure-69-52.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容：

**總體概述:**

這張圖是「指紋比對時間統計圖」（如後文所示），用折線圖的形式比較了兩種指紋比對演算法（FLANN 和 Minutia）在不同數據組上的執行時間。從上下文可知，實驗目的是評估這兩種方法的性能差異，重點關注運行速度。

**圖片細節分析:**

*   **X軸：** 代表「Groups」，可以理解為不同的數據組別或測試案例。總共有60個數據組。
*   **Y軸：** 代表「Time (seconds)」，表示執行時間，單位是秒。
*   **藍色線（FLANN Time Data）：** 表示使用 FLANN 演算法的執行時間曲線。
*   **橘色線（Minutia Time Data）：** 表示使用 Minutia 演算法的執行時間曲線。

**根據圖表數據和上下文，可以得出以下結論：**

1.  **整體性能優勢：** 如前文所述，Minutia Matching 在運算時間上表現出明顯優勢。從圖表中可以看出，橘色線（Minutia）在大部分時間段都低於藍色線（FLANN），表明 Minutia 演算法的執行速度通常比 FLANN 快。
2.  **數據量影響：** 前文提到 FLANN 主要基於快速最近鄰搜尋，因此對於高維特徵數據的處理效率會因數據量增加而降低。圖表中雖然沒有直接顯示數據量，但可以推測在某些數據組（例如，X軸數值較大的位置）FLANN 的執行時間波動較大，可能與數據量的變化有關。
3.  **個別數據組的異常：** 圖中存在一些峰值點，表示部分數據組的執行時間相對較長。後文指出，這些峰值在兩組演算法數據中都出現，表明對於某些特定特徵點資料，無論使用哪種演算法，都需要額外的運算時間來確保精度。
4.  **精度與運算的權衡：** 總體而言，Minutia 在速度上更勝一籌，但兩者在處理特定數據時都需要考慮精度和運算時間的平衡。

**總結:**

這張圖清晰地展示了 FLANN 和 Minutia 兩種指紋比對演算法的執行時間差異。Minutia 通常更快，但對於某些特定的特徵點資料，FLANN 和 Minutia 都可能需要額外的運算時間來提高精度。實驗結果支持前文的觀點，並為未來優化指紋比對方法提供了方向：針對特定類型的指紋數據，可以進一步探討和優化相關運算方法。

---

圖 4.17 指紋比對時間統計圖

另外，從數據圖中可觀察到，部分數據組的執行時間相對較長，且在兩組演 算法數據中皆有出現。由此可知，對於相同組的特徵點資料，使用不同的比對演 算法時，皆需額外的運算時間來確保演算的精度。因此，未來在進行指紋比對研 究時，可以針對此類指紋進一步探討和優化相關運算方法。

綜合分析表明，設計的可重構指紋比對架構成功驗證了其在不同比對模式 下的適應能力。架構能夠根據數據情境靈活切換比對策略，充分體現了其重構能 力，特別是在多模態數據中展現了架構的靈活性。這一結果證明該架構具有良好 的穩定性與靈活性，可在多樣化的任務需求中應用。同時，實驗也揭示了未來的 優化方向，包括提升比對效率與應用範圍，以進一步檢驗架構的通用性與可擴展

性，靈活性使系統在面對新指紋比對技術或更高效的算法時，能以低成本的方式 升級以提高比對效能。

## 4.6 實驗結果分析

本研究為驗證設計的可行性與可重構性，透過 FLANN 與 Minutiae 兩種比 對演算法進行系統切換與驗證，分別評估其執行結果與運算時間。實驗中觀察到 系統能在相同特徵點資料下保持運算準確性，並靈活切換演算法，進一步證明了 設計的高適應性與可重構性。

實驗結果顯示，透過 MIAT 方法論整合大型語言模型所設計的指紋特徵比 對系統，在不同的比對演算法下皆能維持運算效能，並透過 LLM 輔助生成 Grafcet 架構設計，進一步提升了開發效率。此外，系統在可重構設計上的優勢， 使其能夠針對未來的運算瓶頸進行靈活優化，進一步奠定了指紋比對研究的技 術基礎並拓展其應用潛力。整體實驗結果證明了該設計方法在實現高效性與靈 活性上的可行性，並為後續指紋比對技術的優化和擴展提供了重要的參考與驗 證依據。

## 5.1 結論

本研究結合 MIAT 方法論與大型語言模型(LLMs)，提出了一種創新的高效 系統設計方法，並以指紋特徵比對系統為案例進行驗證。研究從系統的階層模組 化設計出發，利用 MIAT 方法論分解並構建了旋轉排除模組、線段方向排除模 組及特徵比對模組。隨後，在方法論的高階合成階段，引入 LLM 自動生成 Grafcet action 的程式碼，實現了高效的離散事件驅動系統開發。通過實驗測試和數據分 析，研究展示了該方法在系統準確性、效率及維護性上的優勢。

實驗結果表明，基於MIAT方法論的模組化設計，顯著提升了系統的穩定性、 功能獨立性和維護的便捷性。此外，透過比較 Minutia 與 FLANN 演算法的運行 結果，評估系統在處理速度和比對精度上的優劣勢。實驗同時關注模組化設計對 系統架構穩定性的影響，通過多組指紋比對測試驗證了其對準確性與速度的支 持，滿足了指紋比對的實際應用需求。其中大型語言模型在程式碼生成中的應用， 顯著提升了開發效率並降低了人為錯誤風險。實驗證實，LLM 能根據 Grafcet 模 型需求生成高準確性的程式碼，大幅縮短開發時間，尤其在處理離散事件驅動程 式設計時展現出強大的適應能力。

本研究的主要貢獻在於首次將 MIAT 方法論與 LLM 結合應用於指紋辨識系 統設計，並驗證了該方法在提升系統開發效率、準確性和可維護性方面的可行性 與有效性。這一創新設計方法不僅為指紋辨識技術的進一步發展提供了新的解 決方案，也為其他高複雜度軟體開發的架構設計和實施提供了參考價值。

## 5.2 未來展望

本研究結合 MIAT 方法論與大型語言模型(LLMs)，提出了一種創新的系統 設計方法，並成功驗證了其在指紋特徵比對系統中的應用價值。然而，隨著技術 的進一步發展和應用需求的多樣化，未來仍有許多值得探索的方向。

未來研究可針對更廣泛的指紋比對應用場景進行探討，隨著軟硬體協同設計 的趨勢，未來研究可以探索 MIAT 方法論與嵌入式硬體平台的深度結合，為物 聯網(IoT)設備或邊緣計算系統提供高效的軟硬體集成解決方案。並在此基礎上， 結合 LLM 自動生成硬體描述語言程式碼，可能進一步提升嵌入式系統設計的效 率和精確性。

## 參考文獻

* [1] A. K. Jain, A. Ross and S. Prabhakar, “An introduction to biometric recognition,” IEEE Transactions on Circuits and Systems for Video Technology, vol. 14, no. 1,

pp. 4-20, Jan. 2004.

* [2] K. Han and X. Li, “Application of Partial Differential Equation Method in Fingerprint Image Enhancement,” 2021 IEEE/ACIS 19th International Conference on Software Engineering Research, Management and Applications (SERA), Kanazawa, Japan, pp. 33-38, 2021.

* [3] E. N. Bifari and L. A. Elrefaei, “Automated Fingerprint Identification System based on weighted feature points matching algorithm,” 2014 International Conference on Advances in Computing, Communications and Informatics (ICACCI), Delhi, India,

pp. 2212-2217, 2014.

* [4] V. Kakani, V. H. Nguyen, B. P. Kumar, H. Kim, V. R. Pasupuleti, “A critical review on computer vision and artificial intelligence in food industry,” Journal of Agriculture and Food Research, vol. 2, no. 100033, 2020.

* [5] A. K. Jain, S. S. Arora, K. Cao, L. Best-Rowden and A. Bhatnagar, “Fingerprint Recognition of Young Children,” IEEE Transactions on Information Forensics and Security, vol. 12, no. 7, pp. 1501-1514, July 2017.

Security, vol. 12, no. 7, pp. 1501-1514, July 2017.

* [6] J. Qi, Z. Shi, X. Zhao and Y. Wang, “A novel fingerprint matching method based on the Hough transform without quantization of the Hough space,” Third International Conference on Image and Graphics (ICIG'04), pp. 262-265, December 2004.

[7] D. Lee, K. Choi and J. Kim, “A robust fingerprint matching algorithm using local alignment,” 2002 International Conference on Pattern Recognition, vol. 3, pp. 803-

806, August 2002.

* [8] P. D. Gutiérrez, M. Lastra, F. Herrera and J. M. Benítez, “A High Performance Fingerprint Matching System for Large Databases Based on GPU,” IEEE Transactions on Information Forensics and Security, vol. 9, no. 1, pp. 62-71, Jan.

* [9] D. Peralta, S. García, J. M. Benitez, F. Herrera, “Minutiae-based fingerprint matching decomposition: Methodology for big data frameworks,” Information

Sciences, vol. 408, pp. 198-212, 2017.

* [10] M.Y. Lin, S.H. Hsieh, C.H. Chen, C.H. Lin, "High-Performance Chip Design with Parallel Architecture for Magnetic Field Imaging System," IEEE Transactions on Instrumentation and Measurement, vol. 73, no. 9502313, pp. 1-13, 2024.

* [11] J. Li, G. Li, Y. Li and Z. Jin, “Structured chain-of-thought prompting for code generation,” 2023, arXiv:2305.06599.

* [12] L. Murr, M. Grainger, D. Gao, “Testing LLMs on Code Generation with Varying Levels of Prompt Specificity,” 2023, arXiv:2311.07599.

* [13] C. C. Hsieh, C. Y. Liu, P. Y. Wu, A. P. Jeng, R. G. Wang, C. C. Chou, “Building information modeling services reuse for facility management for semiconductor fabrication plants,” Automation in Construction, vol. 102, pp. 270-287, 2019.

* [14] Z. Xu, F Xi, L Liu, and L. Chen, “A Method for Design of Modular Reconfigurable Machine Tools,” Machines, vol. 5, no. 1, 2017.

* [15] O. David, J. C. Ascough, W. Lloyd, T. R. Green, K. W. Rojas, G.H. Leavesley, L.R. Ahuja, “A software engineering perspective on environmental modeling framework design: The Object Modeling System,” Environmental Modelling & Software, vol. 39, pp. 201-213, 2013.

* [16] G. Fylaktopoulos, M. Skolarikis, I. Papadopoulos, G. Goumas, A. Sotiropoulos, I. Maglogiannis, “A distributed modular platform for the development of cloud

based applications,” Future Generation Computer Systems, vol. 78, no. 1, pp. 127- 141, 2018.

* [17] J. Wang, L. Cao, X. Luo, Z. Zhou, J. Xie, A. Jatowt, Y. Cai, “Enhancing Large Language Models for Secure Code Generation: A Dataset-driven Study on

Vulnerability Mitigation,” 2023, arXiv:2310.16263.

* [18] V. J. Rathod, N. C. Iyer and Meena S M, “A survey on fingerprint biometric recognition system,” 2015 International Conference on Green Computing and Internet of Things (ICGCIoT), Greater Noida, India, pp. 323-326, 2015.

* [19] J. Bohné and V. Despiégel, “Fingerprint skeleton matching based on local descriptor,” 2009 IEEE 3rd International Conference on Biometrics: Theory,Applications, and Systems, Washington, DC, USA, pp. 1-6, 2009.

* [20] C.H. Chen, C.S. An, C.Y. Chen, “Fingerprint Quality Assessment Based on Texture and Geometric Features,” Journal of Imaging Science and Technology, Journal of Imaging Science and Technology, vol.64, no.4, pp. 40403- 1-40403-7(7), Jul. 2020.

* [21] C.H. Chen, C.Y. Chen, and T.M. Hsu, “Singular Points Detection in Fingerprints Based on Poincare Index and Local Binary Patterns,” Journal of Imaging Science

and Technology, vol. 63, no.3, pp.030401-1-7, Jun. 2019.

* [22] S. Bakheet and A. Al-Hamadi, “Robust hand gesture recognition using multiple shape-oriented visual cues,” J Image Video Proc, vol. 26, pp. 1-18, 2021.

* [23] Kalyani Mali and Samayita Bhattacharya, “Fingerprint Recognition Using Global and Local Structures,” International Journal on Computer Science and Engineering, vol. 3, no. 1, pp. 161-172, Jan. 2011.

* [24] D. Petrovska-Delacretaz, G. Chollet, and B. Dorizzi. Guide to Biometric Reference Systems and Performance Evaluation. Springer, Dordrecht, 2009. 3.

[25] S. Bakheet and A. Al-Hamadi, “A framework for instantaneous driver drowsiness detection based on improved HOG features and naïve Bayesian classification,” Brain Sci., vol. 11, no. 2, pp. 240, Feb. 2021.

* [26] V. Gudkov and D. Lepikhova, “Fingerprint Model Based on Fingerprint Image Topology and Ridge Count Values,” 2018 Global Smart Industry Conference (GloSIC), Chelyabinsk, Russia, pp. 1-5, 2018.

* [27] C. C. Liao and C. T. Chiu, “Fingerprint recognition with ridge features and minutiae on distortion,” 2016 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Shanghai, China, pp. 2109-2113, 2016.

* [28] H. Choi, H. K. Choi and J. Kim, “Fingerprint Matching Incorporating Ridge Features With Minutiae,” IEEE Transactions on Information Forensics and

Security, vol. 6, no. 2, pp. 338-345, 2011.

* [29] C.H. Chen, C.T. Liu, “Person Re-Identification Microservice over Artificial Intelligence Internet of Things Edge Computing Gateway,” Electronics, vol.10, no.18, pp. 2264, 2021.

* [30] A. K. Jain, J. Feng and K. Nandakumar, “Fingerprint Matching,” Computer, vol. 43, no. 2, pp. 36-44, Feb. 2010.

* [31] D. Peralta et al., “A survey on fingerprint minutiae-based local matching for verification and identification: Taxonomy and experimental evaluation,” Information Sciences, vol. 315, pp. 67-87, Sep. 2015.

* [32] K. N. Win, K. Li, J. Chen, P. Fournier-Viger and K. Li, ”Fingerprint classification and identification algorithms for criminal investigation: A survey, “ Future Generation Computer Systems, vol. 110, pp. 758-771, 2020.

* [33] H. Wu, Q. Liu and X. Liu, “A review on deep learning approaches to image classification and object segmentation,” Comput. Mater. Continua, vol. 1, no. 2, pp.

* [34] B. Liu, Z. Li, et al. “Fingerprint reconstruction and recognition based on the three- dimensional structure of fingertip skin,” 5th Optics Young Scientist Summit (OYSS

2022), vol. 12448, 2022.

* [35] A. Mishra, S. Dehuri, “A Novel Hybrid FLANN-PSO Technique for Real Time Fingerprint Classification,” Medico-Legal Update, vol. 19, no. 2, pp. 740-746,

* [36] Y. Zheng and P. Zheng, “Image Matching Based on Harris-Affine Detectors and Translation Parameter Estimation by Phase Correlation,” 2019 IEEE 4th International Conference on Signal and Image Processing (ICSIP), Wuxi, China,

pp. 106-111, 2019.

* [37] S. Insankeovilay, P. Prasarn and S. Choomchuay, “Fingerprint matching with cross correlation and minutiae scores,” The 4th 2011 Biomedical Engineering International Conference, Chiang Mai, Thailand, pp. 174-177, 2012.

* [38] D. Maltoni, D. Maio, A. Jain and S. Prabhakar, Handbook of Fingerprint Recognition, USA, NY, New York:Springer-Verlag, 2009.

* [39] K. Ito, A. Morita, T. Aoki, T. Higuchi, H. Nakajima and K. Kobayashi, “A fingerprint recognition algorithm using phase-based image matching for low- quality fingerprints,” IEEE International Conference on Image Processing 2005, Genova, Italy, pp. 11-33, 2005.

* [40] J. Feng, Z. Ouyang, A. Cai, “Fingerprint matching using ridges,” Pattern Recognition, vol. 39, no. 11, pp. 2131-2140, 2006.

* [41] L. Sha, F. Zhao, X. Tang, “Minutiae-based Fingerprint Matching Using Subset Combination,” ICPR, vol. 4 pp. 566-569, 2006.

* [42] ANSI-INCITS 378-2004, “Information Technology - Finger Minutiae Format for

Data Interchange,” 2004.

* [43] ANSI/NIST-ITL 1-2007, “Data Format for the Interchange of Fingerprint, Facial, Other Biometric Information,” 2007.

[44] J. Bohné and V. Despiégel, “Fingerprint skeleton matching based on local

* descriptor,” 2009 IEEE 3rd International Conference on Biometrics: Theory,Applications, and Systems, Washington, DC, USA, pp. 1-6, 2009.

* [45] K. Nirmalakumari, H. Rajaguru and P. Rajkumar, “Efficient Minutiae Matching Algorithm for Fingerprint Recognition,” 2019 International Conference on Advances in Computing and Communication Engineering (ICACCE), Sathyamangalam, India, pp. 1-5, 2019.

* [46] K. Singh, K. Kaur and A. Sardana, “Fingerprint feature extraction,” Int. J. Comput. Sci. Technol., vol. 2, pp. 237-241, 2011.

* [47] J. Yin, S. Pan, X. Li, S. Yu, Y. Xue and J. Zhou, “Research on Fingerprint Recognition Algorithm Based on Minutiae Matching Pairs,” 2023 3rd International Conference on Electronic Information Engineering and Computer (EIECT), Shenzhen, China, pp. 484-493, 2023.

* [48] I. Kovač, P. Marák, “Openfinger: Towards a combination of discriminative power of fingerprints and finger vein patterns in multimodal biometric system, “ Tatra Mountains Mathematical Publications, vol. 77, no. 1, pp. 109-138, 2020.

* [49] V. Vijayan and P. Kp, “FLANN Based Matching with SIFT Descriptors for Drowsy Features Extraction,” 2019 Fifth International Conference on Image

Information Processing (ICIIP), Shimla, India, 2019, pp. 600-605.

[50] Y.R. Wang, H.X. Li, and L.K. Wang, “Similar image retrieval using color histogram in HSV space and SIFT descriptor with FLANN,” Foundations of Intelligent Systems: Proceedings of the Eighth International Conference on Intelligent Systems and Knowledge Engineering, vol. 277, pp.1085-1093, 2014. [51] R. W. Gowandy, A. Halim, & H. Santoso, ”ELECTRONIC VOTING SYSTEM BASED ON FINGERPRINT RECOGNITION AND RADIO FREQUENCY IDENTIFICATION,” International Journal of Engineering Development And Research, vol. 2, no. 4, pp. 3850-3854, 2017.

* [52] M. Muja and D. G. Lowe, “Scalable Nearest Neighbor Algorithms for High Dimensional Data,” in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 36, no. 11, pp. 2227-2240, Nov. 1, 2014.

* [53] M. Muja and D. G. Lowe, “FLANN—Fast library for approximate nearest neighbor user manual,” Proc. Int. Conf. Comput. Vis. Theory Appl. (VISAPP), pp.

1-29, Jan. 2013.

* [54] D. G. Lowe, “Distinctive image features from scale-invariant keypoints,” International journal of computer vision, vol. 60, no. 2, pp. 91-110, 2004.

* [55] A. Mishra, N. Singh, S. R. Samal and S. Dash, “Biogeography Based Optimized Hybrid Chebyshev FLANN for Fingerprint Classification,” 2023 1st International Conference on Circuits, Power and Intelligent Systems (CCPIS), Bhubaneswar, India, pp. 1-4, 2023.

* [56] Y. T. Fang, and H. Rau. “Optimal consumer electronics product take-back time with consideration of consumer value,” Sustainability, vol. 9, no. 3, pp. 385, 2017. [57] C.H. Chen, M.Y. Lin, X.C. Guo, “High-level Modeling and Synthesis of Smart Sensor Networks for Industrial Internet of Things,” Computers & Electrical Engineering, vol.61, pp.48–66, Jul. 2017.

* [58] M.H. Temsah, A. Jamal, K. Alhasan, A.A. Temsah, K.H. Malki, “OpenAI o1- Preview vs. ChatGPT in Healthcare: A New Frontier in Medical AI Reasoning,”

Cureus, vol. 16, no. 10, pp.70640, 2024.

* [59] A. Jaech, A. Kalai, et al., “OpenAI o1 System Card,” 2024, arXiv:2412.16720.

[60] Z. Liu, Y. Tang, X. Luo, Y. Zhou and L. F. Zhang, “No Need to Lift a Finger

Anymore? Assessing the Quality of Code Generation by ChatGPT,” in IEEE

Transactions on Software Engineering, vol. 50, no. 6, pp. 1548-1584, Jun. 2024.

* [61] D. Huang, Q. Bu, J. Zhang, X. Xie, J. Chen, H. Cui, “Bias assessment and mitigation in LLM-based code generation,” 2023, arXiv:2309.14345.

* [62] Y.H. Liao, “Fingerprint Minutiae Detection and Extraction Algorithm with Software High-Level Modeling and Synthesis,” M.S. thesis, Dept. of Computer Science and Information Engineering, National Central Univ., Taoyuan, Taiwan, 2024. [Online]. Available:

https://ir.lib.ncu.edu.tw:444/thesis/view_etd.asp?URN=110552019&fileName=G C110552019.pdf

* [63] R. Cappelli, D. Maio, D. Maltoni, J. L. Wayman and A. K. Jain, “Performance evaluation of fingerprint verification systems,” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 28, no. 1, pp. 3-18, Jan. 2006.

* [64] L. Murr, M. Grainger, D. Gao, “Testing LLMs on Code Generation with Varying Levels of Prompt Specificity,” 2023, arXiv: 2311.07599.

* [65] A. Buscemi, “A comparative study of code generation using chatgpt 3.5 across 10 programming languages,” 2023, arXiv:2308.04477.

* [66] F. A. Sakib, S. H. Khan and A. H. M. R. Karim, “Extending the Frontier of ChatGPT: Code Generation and Debugging,” 2024 International Conference on

Electrical, Computer and Energy Technologies (ICECET, Sydney, Australia, pp. 1-6, 2024.

* [67] R. Cappelli, M. Ferrara and D. Maltoni, “Minutiae-Based Fingerprint Matching,” Cross Disciplinary Biometric Systems, vol. 37, pp. 117-150, 2012.

* [68] B.Y. Satria, A. Bejo and R. Hidayat, “Fingerprint Enhancement using Iterative Contextual Filtering for Fingerprint Matching,” 2021 9th International Conference on Information and Communication Technology (ICoICT), pp. 186-191, 2021.

## 附錄一 生成 Grafcet 對話流程

首先將原先中文擬定的 Grafcet 翻譯成英文，如附圖 1。

---

![圖片：figure-82-53.jpg](images/figure-82-53.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## 指紋特徵點提取流程圖文字描述

這個Grafcet流程圖實現了指紋特徵點的提取功能。

**1. 初始步驟 (Step 1)：WATER_0**

系統啟動或復位後，首先進入 WATER_0 步驟，此時系統處於待機狀態。在 WATER_0 步驟中，沒有持續執行的動作。

**2. 流程演進：提取特徵點**

從 WATER_0 步驟開始，滿足轉移條件「Feature point extraction」後，系統進入 Step 2 (WATER_1)。
*   在 WATER_1 步驟中，執行動作「Read sample two feature points --> 1」。此動作為賦值型/儲存型動作，只觸發一次。

**3. 分支結構：One segment rotation matching**

從 WATER_1 步驟之後，流程遇到一條橫線，形成分支。根據 Grafcet 規則總綱第4條的判斷，由於在橫線之前沒有共通的轉移條件，因此這是一個**選擇性分支**。系統會根據後續分支的條件是否滿足來選擇執行路徑。

*   **分支1：Rotation matching completed --> Step 3 (WATER_2)**
    *   如果滿足轉移條件「One segment rotation matching completed」，則系統進入 WATER_2 步驟。
    *   在 WATER_2 步驟中，執行動作「One segment direction exclusion --> 1」。此動作為賦值型/儲存型動作，只觸發一次。

*   **分支2：Rotation matching not completed --> Step 4 (WATER_3)**
    *   如果滿足轉移條件「Rotation matching not completed」，則系統進入 WATER_3 步驟。
    *   在 WATER_3 步驟中，執行動作「One segment direction exclusion completed --> 1」。此動作為賦值型/儲存型動作，只觸發一次。

**4. 分支合併：Feature point matching**

從 WATER_2 和 WATER_3 步驟之後，流程再次遇到一條橫線，形成分支合併。
*   無論是通過 WATER_2 還是 WATER_3 進入，滿足轉移條件「Feature point matching」後，系統都將進入 Step 5 (WATER_4)。
*   在 WATER_4 步驟中，執行動作「Feature point matching --> 1」。此動作為賦值型/儲存型動作，只觸發一次。

**5. 完成流程：Similarity accuracy check**

從 WATER_4 步驟之後，滿足轉移條件「Similarity accuracy ---> 1」後，系統進入 Step 6 (WATER_5)。
*   在 WATER_5 步驟中，執行動作「Similarity accuracy --> 1」。此動作為賦值型/儲存型動作，只觸發一次。

**6. 循環返回：初始狀態**

從 WATER_5 步驟之後，系統自動返回到初始步驟 WATER_0，完成一個完整的指紋特徵點提取循環。

**總結:**

整個流程圖描述了一個從待機開始，提取特徵點、進行旋轉匹配判斷、排除方向、進行特徵點匹配以及最後進行相似度準確性檢查的完整過程。 選擇性分支結構允許系統根據旋轉匹配結果選擇不同的執行路徑，最終完成指紋特徵點的提取任務並返回初始狀態等待下一次指令。

---

## 附圖 1 翻譯中文 Grafcet

接著，將繪製英文的 Grafcet 圖片給 ChatGPT 請他敘述後，確認邏輯是否正確如

---

![圖片：figure-82-54.jpg](images/figure-82-54.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> ## 指紋辨識系統 Grafcet 流程圖完整描述

這個 Grafcet 流程圖實現了一個指紋辨識系統的功能，從圖像增強到特徵點提取，最終完成指紋比對的過程。

**1. 初始步驟 (Step 1): 待機狀態**

系統啟動後，進入初始步驟（雙線方塊）。此時，系統處於待機狀態，等待接收指紋圖像輸入。動作為「讀取指紋圖像 Test fingerprint --> 1 (原始圖像)」。

**2. 流程演進：圖像增強 (Step 2)**

當收到原始指紋圖像後（滿足隱含的轉移條件），系統進入步驟 2，進行圖像增強處理。動作為「Image enhancement --> 1 (增強後圖像)」。此步驟持續執行圖像增強操作，直到完成增強過程。

**3. 分支結構：特徵點提取與比對 (Step 3 & Step 4)**

在步驟 2 完成後，系統進入一個分支結構。根據上下文描述，這個分支是**並行分支**，因為在橫線之前有一個共通的轉移條件（圖像增強完成）。因此，兩個分支將同時啟動。

*   **分支一：指紋核心點檢測 (Step 3)**
    *   系統進入步驟 3，進行指紋核心點檢測。動作為「Fingerprint core point detection --> 1 (核心點位置)」。此步驟持續執行核心點檢測操作，直到完成檢測過程。
    *   在步驟 3 完成後，系統進入步驟 4，進行特徵點提取。動作為「Feature point extraction --> 1 (特徵點集合)」。此步驟持續執行特徵點提取操作，直到完成提取過程。
    *   最後，系統進入步驟 5，進行指紋比對。動作為「Fingerprint matching --> 1 (比對結果，成功/失敗)」。

*   **分支二：指紋脊線提取 (Step 4)**
    *   系統同時進入步驟 4（與分支一的步驟 4 不同），進行指紋脊線提取。動作為「Fingerpoint feature extraction --> 1 (特徵點集合)」。此步驟持續執行脊線提取操作，直到完成提取過程。
    *   最後，系統進入步驟 5，進行指紋比對。動作為「Fingerprint matching --> 1 (比對結果，成功/失敗)」。

**4. 分支合併與循環 (Step 5)**

兩個分支在步驟 5 合併。無論是通過核心點檢測還是脊線提取獲得的特徵點集合，都會進入步驟 5 進行指紋比對。比對完成後，系統輸出比對結果（成功或失敗）。

**5. 完成與返回初始狀態**

比對完成後，流程圖沒有明確指示如何返回初始狀態。假設比對成功或失敗後，系統會重置並等待下一次圖像輸入，則可以認為步驟 5 的輸出結果觸發一個隱含的轉移條件，將系統返回到初始步驟（Step 1），開始新的循環。

**總結：**

整個流程圖描述了一個完整的指紋辨識過程，包括圖像增強、核心點檢測與脊線提取（並行進行）、特徵點提取和最終的比對判斷。通過並行分支結構，系統可以同時利用兩種不同的特徵提取方法提高比對的準確性。完成比對後，系統返回待機狀態，等待下一次輸入，形成一個完整的循環工作流程。

---

## 附圖 2 架構邏輯確認

## 接著，確認邏輯無誤後，依照此生成對應程式碼如附圖 3。

附圖 3 生成對應的程式碼

接著，若有子系統並重複上述流程，確認邏輯如附圖 4 後，再將他與主架構程式 結合如附圖 5。

---

![圖片：figure-83-56.jpg](images/figure-83-56.jpg)

**🖼️ VLM 圖片解釋 (類型: Grafcet)：**

> 好的，我將根據提供的 Grafcet 規則總綱和圖片內容，生成一份完整的文字描述。由於圖片解析困難，我會基於圖片中可見的步驟編號和動作描述來推斷流程，並嚴格遵守 Grafcet 的演進規則。

**總體功能：** 此 Grafcet 流程圖實現了線段匹配 (Line Segment Matching) 的功能，包含初始化、排除旋轉影響、排除方向影響等步驟，最終完成匹配判斷。

**初始步驟：**

系統從步驟 40 開始，該步驟為雙線方塊，代表初始步驟。步驟 40 的動作是「模型匹配是否可開始」。這表示系統處於待機狀態，等待外部信號指示是否可以開始匹配流程。

**依序描述流程：**

1.  **從步驟 40 到步驟 41:** 當步驟 40 的條件（“模型匹配是否可開始”）為真時，系統轉移到步驟 41。步驟 41 的動作是「排除旋轉影響 (Line Segment Rotation Exclusion)」。
    *   步驟 41 中包含兩個子動作：`NC_R_setting(x)` 和 `NC_R_writing(x)`，表示設定和寫入旋轉相關的參數 x。

2.  **從步驟 41 到步驟 42:** 當步驟 41 完成後，系統轉移到步驟 42。步驟 42 的動作是「排除方向影響 (Line Segment Direction Exclusion)」。
    *   步驟 42 中包含一個子動作：`NC_D_setting(x)`，表示設定方向相關的參數 x。

3.  **從步驟 42 到步驟 43:** 當步驟 42 完成後，系統轉移到步驟 43。步驟 43 的動作是「匹配判斷」。

4. **分支結構分析：** 從圖中可見，步驟 43 後面連接了多個流程線，且沒有共通的轉移條件在橫線之前，因此可以判定這是一個**選擇性分支**。系統會根據不同的匹配結果選擇不同的路徑執行。

5.  **選擇性分支下的各路徑：**
    *   **路徑一：** 假設步驟 43 的匹配判斷結果為“匹配成功”，則系統進入相應的後續流程（圖中未完整顯示，但可以推測包含處理匹配成功的邏輯）。
    *   **路徑二：** 假設步驟 43 的匹配判斷結果為“匹配失敗”，則系統進入另一個後續流程（圖中未完整顯示，但可以推測包含處理匹配失敗的邏輯）。

6.  **分支合併：** 圖中沒有明確顯示分支合併的位置。但是，根據上下文文字「接著，若有子系統並重複上述流程」，可以推斷，無論選擇哪個路徑，最終都可能返回到步驟 40，以便開始下一次匹配循環。

7. **完整循環：**
    *   系統從步驟 40 開始等待“模型匹配是否可開始”信號。
    *   一旦信號為真，系統依次執行步驟 41（排除旋轉影響）、步驟 42（排除方向影響）和步驟 43（匹配判斷）。
    *   根據步驟 43 的匹配結果，選擇不同的路徑處理。
    *   最終，無論哪個路徑，都可能返回到步驟 40，開始下一次循環。

**總結：**

此 Grafcet 流程圖描述了一個線段匹配的控制邏輯，它首先初始化系統狀態，然後通過排除旋轉和方向影響來提高匹配精度，最後進行匹配判斷並根據結果執行相應的操作。整個流程可以重複執行，以實現持續的線段匹配功能。由於圖片信息不完整，我只能基於可見的部分進行推斷，實際流程可能更加複雜。

---

附圖 4 子系統邏輯敘述確認

---

![圖片：figure-84-57.jpg](images/figure-84-57.jpg)

**🖼️ VLM 圖片解釋 (類型: Other)：**

> 好的，我來為您分析這張圖片及其前後文內容。

**整體理解：**

這張圖片（附圖 4）展示的是一個程式碼片段，描述了子系統的邏輯敘述確認。根據上下文，這個子系統是「指紋比對主流程」（Fingerprint Matching Main Process），更具體地說是包含旋轉與方向排除及特徵比對的部分。

**圖片細節分析：**

*   **程式碼語言：** 圖片中的程式碼看起來像是 Python 或類似的腳本語言，因為使用了 `def` 關鍵字定義函數。
*   **函數名稱和功能：**
    *   `v1_match_rotation(...)`:  推測是進行旋轉比對的函數。參數可能包含輸入圖像、旋轉角度等。
    *   `v1_match_direction(...)`: 推測是進行方向比對的函數。參數可能包含圖像和方向資訊。
    *   `cmp_image_advancement(...)`:  推測是比較圖像進展程度的函數，用於評估比對結果。
    *   `feature_point_extractor_plus(...)`: 提取特徵點的函數，可能使用了更進階的方法（`plus`）。
    *   `cmp_read_complex_text_feature_points(...)`:  比較複雜文字特徵點的函數。
    *   `rotation_matching_completed(...)`:  判斷旋轉比對是否完成的函數。
    *   `direction_matching_completed(...)`: 判斷方向比對是否完成的函數。
    *   `similarity_score(...)`: 計算相似度分數的函數，用於評估比對結果。
    *   `v1_element(Cs)`:  可能是一個基於 `Cs` (可能是配置或參數) 的元素處理函數。
    *   `v1_element2(Cs)`、`v1_element3(Cs)` 等：類似的元素處理函數，可能用於不同的比對階段或不同類型的元素。
*   **程式碼結構：** 程式碼片段呈現了多個函數的定義，這些函數之間可能存在依賴關係，共同構成了指紋比對主流程的核心邏輯。
*   **`ChartGPT` 字樣:**  圖片右下角顯示 `ChatGPT` 的字樣，暗示這段程式碼可能是由 ChatGPT 生成或協助編寫的。

**前後文關聯：**

*   **「附圖 4 子系統邏輯敘述確認」**: 這張圖片是為了驗證子系統（指紋比對主流程）的邏輯是否正確。
*   **「附圖 5 結合子系統與主架構程式」**:  下一張圖片（附圖 5）將展示如何將這個子系統整合到整個主架構程式中，說明了子系統在整體系統中的作用和連接方式。

**總結：**

這張圖片是關於指紋比對子系統的核心邏輯的程式碼片段，它包含了旋轉比對、方向比對、特徵點提取和相似度計算等關鍵功能。通過驗證這個子系統的邏輯，可以確保其在整個指紋識別系統中的正確性和可靠性。 圖片右下角的 `ChatGPT` 字樣提示了程式碼可能與 AI 工具相關。

---

附圖 5 結合子系統與主架構程式

## 附錄二 可重構指紋比對 Grafcet Action

#include <stdio.h>

// 主流程狀態變數

int X0 = 1, X1 = 0, X2 = 0, X3 = 0, X4 = 0;

// 狀態 4 的子流程變數

int X40 = 1, X41 = 0, X42 = 0, X43 = 0;

// 狀態 41 的子流程變數

int X410 = 1, X411 = 0, X412 = 0, X413 = 0, X414 = 0, X415 = 0, X416 = 0, X417 = 0, X418 = 0;

// 狀態 42 的子流程變數

int X420 = 1, X421 = 0, X422 = 0, X423 = 0, X424 = 0, X425 = 0;

// 狀態 430 的子流程變數

int X430 = 1, X431 = 0, X432 = 0, X433 = 0, X434 = 0;

// 主流程條件變數

int initial0 = 0;

int image_enhancement_1 = 0;

int feature_extraction_2_3 = 0;

int feature_point_matching_4 = 0;

// 狀態 4 子流程條件變數

int read_sample_test_feature_points_40 = 0;

int rotation_matching_completed_41 = 0;

int segment_direction_matching_completed_42 = 0;

int similarity_score_43 = 0;

// 狀態 41 子流程條件變數

int get_data_410 = 0;

int line_similarity_calculation_completed_411 = 0;

int bifurcation_point_calculation_completed_412 = 0;

int curvature_calculation_completed_413 = 0;

int ridge_density_calculation_414 = 0;

int rotation_points_remaining_for_calculation_415 = 0;

int rotation_point_calculation_completed__415 = 0;

int next_rotation_point_416 = 0;

int rotation_angle_determination_completed_417 = 0;

int rotation_point_exclusion_completed_418 = 0;

int user_input_415=0;//輸入假設是否判斷完成 int user_input_422=0; int user_input_432=0;

// 狀態 42 子流程條件變數

int rotation_matching_completed_420 = 0;

int difference_computation_completed_421 = 0;

int histogram_computation_completed_422 = 0;

int segments_remaining_for_computation_422 = 0;

int next_segment_423 = 0;

int segment_determination_completed_424 = 0;

int segment_exclusion_completed_425 = 0;

## // 狀態 430 子流程條件變數

int line_end_comparison_completed_431 = 0; int error_matching_completed_432 = 0; int line_ends_remaining_for_computation_432 = 0;

int segment_direction_matching_completed_430 = 0;

int line_end_comparison_completed_431 = 0;

int error_matching_completed_432 = 0;

int line_ends_remaining_for_computation_432 = 0;

int next_line_end_433 = 0;

int similarity_calculation_completed_434 = 0;

void grafcet(); // 主流程狀態機 void grafcet4(); // 狀態 4 子流程狀態機 void grafcet41(); // 狀態 41 子流程狀態機 void grafcet42(); // 狀態 42 子流程狀態機 void grafcet43(); void datapath(); // 主流程動作 void datapath4(); // 狀態 4 子流程動作 void datapath41(); // 狀態 41 子流程動作 void datapath42(); // 狀態 42 子流程動作 void datapath43();

## // 動作函數

void action0(); void Image_Enhancement(); void Core_Point_Processing(); void Minutia_Extraction(); void Minutia_Matching(); void action40(); void Line_Rotation_Exclusion(); void Line_Orientation_Exclusion(); void Minutia_Matching_Similarity(); void action410(); void Line_Similarity_Calculation(); void Minutia_Type_Calculation(); void Minutia_Curvature_Calculation(); void Minutia_Average_Ridge_Density_Calculation(); void Build_Rotation_Histogram(); void Compare_Next_Rotation_Point(); void Rotation_Angle_Determination(); void Rotation_Point_Exclusion(); void action420(); void Line_Orientation_Difference_Calculation(); void Build_Translation_Histogram(); void Compare_Next_Translation_Point(); void Line_Determination(); void Line_Exclusion(); void action430(); void Line_Endpoint_Difference_Test(); void False_Minutia_Matching_Exclusion(); void Compare_Next_Endpoint(); void Similarity_Calculation();

printf("Grafcet simulation starting...\n");

datapath(); // 執行當前狀態動作

grafcet(); // 主流程狀態轉換

// 主流程動作

void datapath()

if (X0 == 1)

if (X1 == 1)

Image_Enhancement();

if (X2 == 1)

Core_Point_Processing();

if (X3 == 1)

Minutia_Extraction();

if (X4 == 1)

Minutia_Matching();

// 狀態 4 子流程動作

void datapath4()

if (X40 == 1)

action40();

if (X41 == 1)

Line_Rotation_Exclusion();

if (X42 == 1)

Line_Orientation_Exclusion();

if (X43 == 1)

Minutia_Matching_Similarity();

// 狀態 41 子流程動作

void datapath41()

if (X410 == 1)

action410();

if (X411 == 1)

Line_Similarity_Calculation();

if (X412 == 1)

Minutia_Type_Calculation();

if (X413 == 1)

Minutia_Curvature_Calculation();

if (X414 == 1)

Minutia_Average_Ridge_Density_Calculation();

if (X415 == 1)

Build_Rotation_Histogram();

if (X416 == 1)

Compare_Next_Rotation_Point();

if (X417 == 1)

Rotation_Angle_Determination();

if (X418 == 1)

Rotation_Point_Exclusion();

// 狀態 42 子流程動作

void datapath42()

if (X420 == 1)

action420();

if (X421 == 1)

Line_Orientation_Difference_Calculation();

if (X422 == 1)

Build_Translation_Histogram();

if (X423 == 1)

Compare_Next_Translation_Point();

if (X424 == 1)

Line_Determination();

if (X425 == 1)

Line_Exclusion();

void datapath43()

if (X430 == 1)

action430();

if (X431 == 1)

Line_Endpoint_Difference_Test();

if (X432 == 1)

False_Minutia_Matching_Exclusion();

if (X433 == 1)

Compare_Next_Endpoint();

if (X434 == 1)

Similarity_Calculation();

// 主流程狀態機

void grafcet()

if (X0 == 1 && initial0 == 1)

initial0 = 0;

if (X1 == 1 && image_enhancement_1 == 1)

image_enhancement_1 = 0;

if (X2 == 1 && feature_extraction_2_3 == 1)

feature_extraction_2_3 = 0;

if (X3 == 1 && feature_point_matching_4 == 1)

feature_point_matching_4 = 0;

if (X4 == 1)

datapath4();

grafcet4();

if (X40 == 1 && X41 == 0 && X42 == 0 && X43 == 0)

// 狀態 4 子流程狀態機

void grafcet4()

if (X40 == 1 && read_sample_test_feature_points_40 == 1)

read_sample_test_feature_points_40 = 0;

if (X41 == 1)

datapath41();

grafcet41();

if (X42 == 1 )

if (rotation_matching_completed_420 == 0)

rotation_matching_completed_420 = 1; // 初始化條件

datapath42(); // 呼叫狀態 42 的動作

grafcet42(); // 處理 42 的子流程狀態

if (X43 == 1)

datapath43(); // 執行 430 子流程動作 grafcet43(); // 更新 430 子流程狀態

// 狀態 41 子流程狀態機

void grafcet41()

if (X410 == 1 && get_data_410 == 1)

get_data_410 = 0;

if (X411 == 1 && line_similarity_calculation_completed_411 == 1)

line_similarity_calculation_completed_411 = 0;

if (X412 == 1 && bifurcation_point_calculation_completed_412 == 1)

bifurcation_point_calculation_completed_412 = 0;

if (X413 == 1 && curvature_calculation_completed_413 == 1)

curvature_calculation_completed_413 = 0;

if (X414 == 1 && ridge_density_calculation_414 == 1)

ridge_density_calculation_414 = 0;

if (X415 == 1)

if (rotation_points_remaining_for_calculation_415 == 1)

rotation_points_remaining_for_calculation_415=0;

else if (rotation_point_calculation_completed__415 == 1)

rotation_point_calculation_completed__415=0;

if (X416 == 1 && next_rotation_point_416 == 1)

next_rotation_point_416 = 0;

if (X417 == 1 && rotation_angle_determination_completed_417 == 1)

rotation_angle_determination_completed_417 = 0;

if (X418 == 1 && rotation_point_exclusion_completed_418 == 1)

rotation_point_exclusion_completed_418 = 0;

// 狀態 42 子流程狀態機邏輯

void grafcet42()

if (X420 == 1 && rotation_matching_completed_420 == 1)

rotation_matching_completed_420 = 0; // 重置條件

if (X421 == 1 && difference_computation_completed_421 == 1)

difference_computation_completed_421 = 0; // 重置條件

if (X422 == 1)

if (segments_remaining_for_computation_422 == 1)

segments_remaining_for_computation_422=0;

else if (histogram_computation_completed_422 == 1)

histogram_computation_completed_422=0;

if (X423 == 1 && next_segment_423 == 1)

X420 = 1; // 回到 420 處理下一段 next_segment_423 = 0; // 重置條件

if (X424 == 1 && segment_determination_completed_424 == 1)

segment_determination_completed_424 = 0; // 重置條件

if (X425 == 1 && segment_exclusion_completed_425 == 1)

X420 = 1; // 回到 420 開始新的循環

segment_exclusion_completed_425 = 0; // 重置條件

void grafcet43()

if (X430 == 1 && segment_direction_matching_completed_430 == 1)

segment_direction_matching_completed_430 = 0; // 重置條件

if (X431 == 1 && line_end_comparison_completed_431 == 1)

line_end_comparison_completed_431 = 0; // 重置條件

if (X432 == 1)

if (line_ends_remaining_for_computation_432 == 1)

line_ends_remaining_for_computation_432=0;

else if (error_matching_completed_432 == 1)

error_matching_completed_432=0;

if (X433 == 1 && next_line_end_433 == 1)

X430 = 1; // 回到 430 處理下一段 next_line_end_433 = 0; // 重置條件 return;

if (X434 == 1 && similarity_calculation_completed_434 == 1)

X430 = 1; // 子流程完成後返回 430

similarity_calculation_completed_434 = 0; // 重置條件

// 動作函數 void action0() { printf("State 0: Initializing...\n"); initial0 = 1; } void Image_Enhancement() { printf("State 1: Performing image enhancement...\n"); image_enhancement_1 = 1; } void Core_Point_Processing() { printf("State 2: Core point processing...\n"); feature_extraction_2_3 = 1; } void Minutia_Extraction() { printf("State 3: Feature point extraction...\n"); feature_point_matching_4 = 1; } void Minutia_Matching() { printf("State 4: Entering sub-process...\n"); } void action40() { printf("State 40: Reading sample/test feature points...\n"); read_sample_test_feature_points_40 = 1; } void Line_Rotation_Exclusion() { printf("State 41: Performing rotation exclusion...\n");

rotation_matching_completed_41 = 1;

printf("X410 = %d,X411 = %d,X412 = %d,X413 = %d,X414 = %d,X415 = %d,X416 =

%d,X417 = %d,X418 = %d \n",

X410 ,X411 ,X412 ,X413 ,X414 ,X415 ,X416 ,X417 ,X418);

void Line_Orientation_Exclusion() {

printf("State 42: Performing segment direction exclusion...\n");

segment_direction_matching_completed_42 = 1;

printf("X420 = %d,X421 = %d,X422 = %d,X423 = %d,X424 = %d,X425 =

%d\n",X420 ,X421 ,X422 ,X423 ,X424 ,X425 );

void Minutia_Matching_Similarity() {

printf("State 43: Performing feature matching...\n");

similarity_score_43 = 1;

printf("X430 = %d,X431 = %d,X432 = %d,X433 = %d,X434 = %d\n",X430 ,X431 ,X432 ,X433 ,X434 ); } void action410() { printf("State 410: Getting data...\n"); get_data_410 = 1; } void Line_Similarity_Calculation() { printf("State 411: Calculating line similarity...\n"); line_similarity_calculation_completed_411 = 1; } void Minutia_Type_Calculation() { printf("State 412: Calculating bifurcation point...\n"); bifurcation_point_calculation_completed_412 = 1; } void Minutia_Curvature_Calculation() { printf("State 413: Calculating curvature...\n"); curvature_calculation_completed_413 = 1; } void Minutia_Average_Ridge_Density_Calculation() { printf("State 414: Calculating ridge density...\n"); ridge_density_calculation_414 = 1; }

void Build_Rotation_Histogram() {

printf("State 415: Constructing rotational histograms...\n");

printf("Enter 1 for remaining points or 2 for completed: "); scanf("%d", &user_input_415); if (user_input_415 == 1)

rotation_points_remaining_for_calculation_415 = 1;

else if (user_input_415 == 2)

rotation_point_calculation_completed__415 = 1;

void Compare_Next_Rotation_Point() {

printf("State 416: Comparing next rotational point...\n");

next_rotation_point_416 = 1;

void Rotation_Angle_Determination() {

printf("State 417: Determining rotation angle...\n");

rotation_angle_determination_completed_417 = 1;

void Rotation_Point_Exclusion() {

printf("State 418: Excluding rotation point...\n\n");

rotation_point_exclusion_completed_418 = 1;

rotation_matching_completed_41=0 ;

// 動作函數

void action420() {

printf("State 420: Performing rotation matching...\n");

rotation_matching_completed_420 = 1;

void Line_Orientation_Difference_Calculation() {

printf("State 421: Computing segment direction differences...\n");

difference_computation_completed_421 = 1;

void Build_Translation_Histogram() {

printf("State 422: Constructing transformation histogram...\n");

// int user_input;

printf("Enter 1 for remaining segments, 2 for completed histogram: ");

scanf("%d", &user_input_422);

if (user_input_422 == 1)

segments_remaining_for_computation_422 = 1;

else if (user_input_422 == 2)

histogram_computation_completed_422 = 1;

void Compare_Next_Translation_Point() {

printf("State 423: Comparing next segment...\n");

next_segment_423 = 1;

void Line_Determination() {

printf("State 424: Determining segment...\n");

segment_determination_completed_424 = 1;

void Line_Exclusion() {

printf("State 425: Excluding segment...\n\n");

segment_exclusion_completed_425 = 1;

segment_direction_matching_completed_42 = 0;

void action430() {

printf("State 430: Matching segment directions...\n");

segment_direction_matching_completed_430 = 1;

void Line_Endpoint_Difference_Test() {

printf("State 431: Testing line end differences...\n");

line_end_comparison_completed_431 = 1;

void False_Minutia_Matching_Exclusion() {

printf("State 432: Excluding defective feature points...\n"); printf("Enter 1 for remaining line ends, 2 for error matching complete: "); scanf("%d", &user_input_432);

if (user_input_432 == 1)

line_ends_remaining_for_computation_432 = 1;

else if (user_input_432 == 2)

error_matching_completed_432 = 1;

void Compare_Next_Endpoint() {

printf("State 433: Comparing next line end...\n");

next_line_end_433 = 1;

void Similarity_Calculation() {

printf("State 434: Calculating similarity...\n\n");

similarity_calculation_completed_434 = 1;

similarity_score_43 = 0;

